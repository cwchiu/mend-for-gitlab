!function(e){var t={};function r(o){if(t[o])return t[o].exports;var n=t[o]={i:o,l:!1,exports:{}};return e[o].call(n.exports,n,n.exports,r),n.l=!0,n.exports}r.m=e,r.c=t,r.d=function(e,t,o){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:o})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(r.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)r.d(o,n,function(t){return e[t]}.bind(null,n));return o},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=22)}([function(e,t){e.exports=require("renovate/dist/logger")},function(e,t){e.exports=require("got")},function(e,t,r){const o=r(10),n=r(1),{logger:s}=r(0);let i=null,a=null,u=null,c=0,l=null;let p=[];let d=[];const g={remediate:8,"rebase-request":15,"master-issue-check":17,"onboarding-update":20,"pr-update":30,"closed-pr-rename":35,"manual-pr-merge":40,"repositories-added":50,installed:60,"master-commit":70,automerge:80,"manual-pr-close":90,scheduled:100};function f(e,t,r,o,n={}){const a=g[t]||100;for(let u=0;u<r.length;u+=1){i=new Date;const c=r[u];s.debug({uniqueKey:c.uniqueKey,repository:c.repository,reason:t,priority:a},"Job queue: enqueing job");const l=d.find(e=>e.uniqueKey===c.uniqueKey);if(l)s.debug({repository:l.repository,uniqueKey:l.uniqueKey},"Job queue: Existing job found for repository"),l.priority>a?(s.debug({repository:l.repository,uniqueKey:l.uniqueKey,existingPriority:l.priority,priority:a},"Job queue: Increasing priority of existing job"),l.reason=t,l.priority=a,l.logContext=e):s.debug({repository:c,existingPriority:l.priority,priority:a},"Job queue: Existing job does not need priority bump");else{const r={reason:t,repository:c.repository,uniqueKey:c.uniqueKey,priority:a,logContext:e,params:n};o&&(r.installationId=o[u]),d.push(r)}h()}}const b={};function h(){d.sort((e,t)=>e.priority-t.priority)}e.exports={getJobsStatus:function(){return{jobs:{lastEnqueueDate:i,lastJobDispatchDate:a,lastJob:u,lastJobFinished:l,queueLength:d.length,totalJobsProcessed:c},jobsInProgress:p}},enqueueRepos:function(e,t,r,o=[],n={}){if("remediate"===t){s.trace("Remediate event received");for(let t=0;t<r.length;t+=1){const i=r[t],a=o[t];b[i.uniqueKey]&&(s.debug({repository:i.uniqueKey},"Debouncing"),clearTimeout(b[i.uniqueKey])),b[i.uniqueKey]=setTimeout(()=>{s.debug({repository:i.uniqueKey},"Enqueuing remediate job"),delete b[i.uniqueKey],f(e,"remediate",[i],[a],n)},1e4)}}else f(e,t,r,o,n)},dequeueRepos:function(e){s.debug({repos:e},"Job queue: Dequeuing repositories"),d=d.filter(t=>!e.includes(t.uniqueKey))},deleteInstallationJobs:function(e){s.debug({installationId:e},"Job queue: deleting jobs for installation"),d=d.filter(t=>t.installationId!==e)},nextJob:async function(){if(global.remediateServerUrl)try{return s.trace("Fetching next job from "+global.remediateServerUrl),(await n(global.remediateServerUrl+"/jobs/next",{timeout:{request:1e4}}).json()).job}catch(e){return s.info({err:e},"Error getting next job from remediate-server"),s.debug("Sleeping 10s"),await o(1e4),null}!function(){for(;p.length&&p[0].started<new Date-36e5;)p.shift()}();const e=p.map(e=>e.repository),t=d.findIndex(t=>!e.includes(t.uniqueKey));if(-1===t)return null;const r=d[t];return d.splice(t,1),s.debug({job:r},"Job queue: returning next job"),u=r,a=new Date,c+=1,p.push({uniqueKey:r.uniqueKey,repository:r.repository,started:a}),r},getJobList:function(){return d},sortJobs:h,finishJob:async function(e){if(global.remediateServerUrl)try{await n.put(global.remediateServerUrl+"/jobs/finish",{json:{job:e}})}catch(e){s.warn({err:e},"Error sending finish job to remediate-server"),s.debug("Sleeping 10s"),await o(1e4)}else s.debug({job:e},"Job queue: job finished"),l={...e,finished:new Date},p=p.filter(t=>t.uniqueKey!==e.uniqueKey)}}},function(e,t){e.exports=require("url")},function(e,t){e.exports=require("crypto")},function(e,t){e.exports=require("proper-url-join")},function(e,t){e.exports=require("@sindresorhus/is")},function(e,t){e.exports=require("jsonwebtoken")},function(e,t,r){const{DefaultAzureCredential:o}=r(16),{SecretClient:n}=r(17),s=r(6),{logger:i}=r(0),{massagePgpKey:a}=r(19);function u(){const e=new o;return new n(process.env.AZURE_KEYVAULT_LOCATION,e)}e.exports={azSecretClient:u,fetchHostRulesSecretFromVault:async function(){try{const e=u(),t=process.env.GH_APP_KEYVAULT_SECRET_GPG||"HostRules";if(i.debug("Fetching GPG key from Vault "+t),s.string(process.env.WS_HOST_RULES_PRIVATE_KEY))i.info("Using GPG key from env"),process.env.RENOVATE_PRIVATE_KEY=process.env.WS_HOST_RULES_PRIVATE_KEY;else{i.info("Fetching PGP key from Vault");const{value:r}=await e.getSecret(t);process.env.RENOVATE_PRIVATE_KEY=a(r),i.info("Retrieved GPG key from Vault")}}catch(e){i.error({err:e},"Error retrieving host rule secret"),process.exit()}}}},function(e,t){e.exports=require("renovate/dist/util/git/private-key")},function(e,t){e.exports=require("delay")},function(e,t){e.exports=require("fs")},function(e,t){e.exports=require("renovate/dist/util/git")},function(e,t,r){const o=r(1),n=r(7);let s,i,a;function u(e=300){const t={iss:i},r={expiresIn:e,algorithm:"RS256"};return n.sign(t,a,r)}e.exports={setCredentials:function(e,t,r){s=e,i=t,a=r},getAppToken:u,getInstallationToken:async function(e){const t=`${s}app/installations/${e}/access_tokens`,r={headers:{accept:"application/vnd.github.machine-man-preview+json",authorization:"Bearer "+u()}};return(await o.post(t,r).json()).token}}},function(e,t){e.exports=require("fs-extra")},function(e,t){e.exports=require("renovate/dist/config")},function(e,t){e.exports=require("@azure/identity")},function(e,t){e.exports=require("@azure/keyvault-secrets")},function(e,t,r){const{init:o}=r(62),{filterInstallations:n}=r(72),{getRepoConfig:s}=r(73);e.exports={init:o,filterInstallations:n,getRepoConfig:s}},function(e,t,r){const{logger:o}=r(0),n="-----BEGIN PGP PRIVATE KEY BLOCK-----\n\n";e.exports={massagePgpKey:function(e){let t=e;return t.startsWith(n)||(o.debug("Massaging PGP key header and footer"),t=`${n}${t}\n-----END PGP PRIVATE KEY BLOCK-----`),t}}},function(e,t,r){const o=r(4);e.exports={generateAuthHeaderContent:function(e,t){return o.createHmac("sha1",t).update(e).digest("hex")}}},function(e,t){e.exports={whitesourceToRenovateDatasourceMapping:{GO:"go",Java:"maven","javascript/Node.js":"npm",Nuget:"nuget",PHP:"packagist",Python:"pypi",Ruby:"rubygems"},datasourceManagers:{go:["gomod"],maven:["maven","gradle"],npm:["npm"],packagist:["composer"],nuget:["nuget"],pypi:["pip_requirements","pip_setup","pipenv","poetry"],rubygems:["bundler"]}}},function(e,t,r){const o=r(6),n=r(23),s=r(24),i=r(1),a=r(25),u=r(26),c=r(27),{logger:l}=r(0),{setPrivateKey:p}=r(9),{getJobsStatus:d,nextJob:g,finishJob:f}=r(2),{getSchedulerStatus:b,startScheduler:h}=r(28),{validateInputs:m}=r(30),{getWebhooksStatus:v,startWebhooksListener:y}=r(40),{getWorkerStatus:E,startWorker:R}=r(50),T=r(18);let _;process.on("unhandledRejection",e=>{l.error({err:e},"Caught an unhandledRejection - exiting to attempt recovery. Container must be restarted"),process.exit(1)});const O=new Date;(async()=>{"enterprise"===process.env.WS_PLATFORM?global.appName="Mend Remediate":"github.com"===process.env.WS_PLATFORM?global.appName="Mend Remediate for GitHub.com":"azure"===process.env.WS_PLATFORM?global.appName="Mend Remediate for Azure Devops":"bitbucket"===process.env.WS_PLATFORM?global.appName="Mend Remediate for Bitbucket Cloud":(delete process.env.WS_PLATFORM,global.appName="Mend Renovate On-Prem"),l.info("Launching "+global.appName),process.env.WS_PLATFORM&&await T.init();let e=await a.parseConfigs(process.env,process.argv);!function(e){l.info("Initializing Renovate core"),c.bootstrap(),global.appMode=!0,u.init({...e,cacheDir:"/tmp/renovate/cache/renovate/"}),e.gitPrivateKey?(l.info("gitPrivateKey: value found in global config"),p(e.gitPrivateKey)):l.debug("gitPrivateKey: no value found")}(e),await m(),e=await a.parseConfigs(process.env,process.argv),e=function(e){if(process.env.GITHUB_COM_TOKEN)return"https://api.github.com/"===process.env.RENOVATE_ENDPOINT&&(l.warn("No need to configure GITHUB_COM_TOKEN for github.com - it will be ignored"),delete process.env.GITHUB_COM_TOKEN),e;if("https://api.github.com/"===process.env.RENOVATE_ENDPOINT||"github.com"===process.env.WS_PLATFORM)return e;l.warn("You should configure GITHUB_COM_TOKEN as otherwise the github.com API is heavily rate limited. Release notes and github-sourced packages will now be disabled.");const t=JSON.parse(JSON.stringify(e));return t.fetchReleaseNotes=!1,t.packageRules=t.packageRules||[],t.packageRules.push({description:"Disable managers to avoid github.com requests and rate limiting",matchDatasources:["github-tags","github-releases","go"],enabled:!1}),t}(e),e.gitAuthor=e.gitAuthor||global.gitAuthor,o.nonEmptyArray(e.gitIgnoredAuthors)||(e.gitIgnoredAuthors=["bot@renovateapp.com","renovate@whitesourcesoftware.com"]),h(e),R(e),_=n(),_.use(s.json({limit:"50mb",extended:!0})),_.get("/",(e,t)=>{t.status(200).send({status:"OK"})}),_.get("/status",(e,t)=>{if(process.env.WS_API_SECRET&&e.header("authorization")!==process.env.WS_API_SECRET)return t.sendStatus(401);const r={bootDate:O,...b(),...v(),...d(),...E()};return t.status(200).send({status:r})}),process.env.WS_PLATFORM&&_.get("/controller-connected",async(e,t)=>{let r=!1;const o=(process.env.WS_CONTROLLER_DESTINATION_URL||process.env.CONTROLLER_DESTINATION_URL)+"/payload/healthcheck";try{200===(await i.get(o,{retry:0})).statusCode&&(r=!0)}catch(e){l.info("Unable to connect to the controller.")}t.status(200).send({connected:r})}),global.remediateServerOnly&&(l.debug("Enabling job API in server mode"),_.get("/jobs/next",async(e,t)=>{const r=await g();t.status(200).send({job:r})}),_.put("/jobs/finish",async(e,t)=>{const r=e.body.job;await f(r),t.status(200).send({})})),await y(_,e),function(){_.use((e,t)=>{t.status(404).send({url:e.originalUrl,message:"Not found"})});const e=process.env.PORT||8080,t=_.listen(e,()=>{l.info("Server bound to port "+t.address().port)})}()})()},function(e,t){e.exports=require("express")},function(e,t){e.exports=require("body-parser")},function(e,t){e.exports=require("renovate/dist/workers/global/config/parse")},function(e,t){e.exports=require("renovate/dist/util/cache/package")},function(e,t){e.exports=require("renovate/dist/proxy")},function(e,t,r){const{CronJob:o}=r(29),n=r(1),{logger:s}=r(0);let i,a,u,c=null;e.exports={getSchedulerStatus:function(){return{scheduler:{platform:a,cron:u,lastScheduling:c}}},startScheduler:function(e){if(global.remediateServerUrl)s.debug("Skipping scheduler as in worker mode");else{s.debug("Starting scheduler");try{if(a=process.env.RENOVATE_PLATFORM,"github"===process.env.RENOVATE_PLATFORM&&"github.com"===process.env.WS_PLATFORM)return a=process.env.WS_PLATFORM,void s.info("Skipping job scheduler. Scheduled jobs will be initiated by the ws-controller.");if("azure"===process.env.RENOVATE_PLATFORM)return void s.info("Skipping job scheduler. Scheduled jobs will be initiated by the ws-controller.");u=process.env.SCHEDULER_CRON||"0 * * * *",s.info("Using cron schedule: "+u),s.debug("Current datetime = "+(new Date).toString()),i=new o({cronTime:u,onTick:()=>(c=new Date,async function(){s.info("Scheduler being triggered in controller");try{const e=`${process.env.WS_CONTROLLER_DESTINATION_URL||process.env.CONTROLLER_DESTINATION_URL}/remediate/scheduledJob?timestamp=${Date.now()}&jobType=${a}-remediate-schedule`;await n(e,{timeout:{request:1e4}})}catch(e){s.error({err:e,message:e.message},"Problem communicating to the controller by the remediate scheduler")}}()),start:!1,runOnInit:!1})}catch(e){s.error("Invalid cron value"),process.exit(0)}i.start(),s.info("Job scheduler started")}}}},function(e,t){e.exports=require("cron")},function(e,t,r){const{logger:o}=r(0),{validateBitbucketServerInputs:n}=r(31),{validateGitHubInputs:s}=r(34),{validateGitLabInputs:i}=r(35),{validateEnv:a}=r(37),{validateLicense:u}=r(38);e.exports={validateInputs:async function(){o.info("Validating inputs"),u(),a(),"github"===process.env.RENOVATE_PLATFORM?await s():"gitlab"===process.env.RENOVATE_PLATFORM?await i():"bitbucket-server"===process.env.RENOVATE_PLATFORM?await n():"bitbucket"===process.env.RENOVATE_PLATFORM?o.info("Remediate does not need inputs validated for Bitbucket"):"azure"===process.env.RENOVATE_PLATFORM?o.info("Remediate does not need inputs validated for Azure"):(o.error("Unknown platform: "+process.env.RENOVATE_PLATFORM),process.exit(0))}}},function(e,t,r){const{exec:o}=r(32),n=r(1),s=r(3),{logger:i}=r(0),{initPlatform:a}=r(33);e.exports={validateBitbucketServerInputs:async function(){i.info("Using Bitbucket Server endpoint: "+process.env.RENOVATE_ENDPOINT),process.env.RENOVATE_USERNAME&&process.env.RENOVATE_PASSWORD||(i.error("You need to configure RENOVATE_USERNAME and RENOVATE_PASSWORD for your bot account"),process.exit(0));try{const e=(e=>Buffer.from(e,"binary").toString("base64"))(`${process.env.RENOVATE_USERNAME}:${process.env.RENOVATE_PASSWORD}`);process.env.BBTOKEN=e;const t=s.resolve(process.env.RENOVATE_ENDPOINT,"./rest/api/1.0/users/"+process.env.RENOVATE_USERNAME),r={headers:{Authorization:"Basic "+e}},u=await n(t,r).json();i.debug({user:u}),i.info("Authenticated as Bitbucket user: "+process.env.RENOVATE_USERNAME),await a({endpoint:process.env.RENOVATE_ENDPOINT,username:process.env.RENOVATE_USERNAME,password:process.env.RENOVATE_PASSWORD}),global.botUsername=u.name,global.botUserId=u.id,process.env.RENOVATE_GIT_AUTHOR=process.env.RENOVATE_GIT_AUTHOR||`${u.displayName} <${u.emailAddress}>`,await o(`git config --global user.email "${u.emailAddress}"`),await o(`git config --global user.name "${u.displayName}"`)}catch(e){i.error({err:e,body:e.response?e.response.body:void 0},"Bitbucket Server authentication failed"),process.exit(0)}}}},function(e,t){e.exports=require("child-process-promise")},function(e,t){e.exports=require("renovate/dist/modules/platform/bitbucket-server")},function(e,t,r){const o=r(11),n=r(1),s=r(3),{logger:i}=r(0),{setGitAuthor:a}=r(12),{setCredentials:u,getAppToken:c}=r(13);e.exports={validateGitHubInputs:async function(){i.info("Using GitHub endpoint: "+process.env.RENOVATE_ENDPOINT),process.env.GITHUB_APP_ID||(i.error("You must set GITHUB_APP_ID"),process.exit(0));if(!process.env.GITHUB_APP_KEY){i.info("GITHUB_APP_KEY not set - attempting to read pem file from disk");let e="";try{e=o.readFileSync("/usr/src/app/renovate.private-key.pem","utf8")}catch(e){i.debug({err:e,message:e.message},"err reading pemfile")}e&&e.length?(process.env.GITHUB_APP_KEY=e,i.info("Read private key from disk")):(i.error("You must provide a GitHub App Key via GITHUB_APP_KEY or pem file"),process.exit(0))}process.env.RENOVATE_TOKEN&&(i.warn("You should not configure GITHUB_TOKEN or RENOVATE_TOKEN if using Renovate in GHE App mode. It will be ignored."),delete process.env.RENOVATE_TOKEN);const e=process.env.GITHUB_APP_ID,t=process.env.GITHUB_APP_KEY.replace(/\\n/g,"\n");u(process.env.RENOVATE_ENDPOINT,e,t);const r=process.env.RENOVATE_ENDPOINT+"app",l={headers:{accept:"application/vnd.github.machine-man-preview+json",authorization:"Bearer "+c()}};try{const e=await n(r,l).json();i.trace({res:e}),i.info("Authenticated as GitHub app: "+e.name);const t=(e.slug||e.name.toLowerCase().replace(/\s/g,"-").replace(/\./g,"-").replace(/-+/g,"-"))+"[bot]";global.botUsername=t,global.renovateUsername=t;const o=function(e){const t=s.parse(e),r=`${t.path.split("/").pop()}[bot]@users.noreply.${t.hostname}`;return i.info({email:r},"Email configured"),r}(e.html_url);i.info({username:t,email:o},"Platform username/email"),global.gitAuthor=`${t} <${o}>`,a(global.gitAuthor)}catch(e){i.error({err:e,body:e.response?e.response.body:void 0},"GitHub App ID/Key is not accepted"),process.exit(0)}}}},function(e,t,r){const o=r(1),n=r(3),{logger:s}=r(0),{initPlatform:i}=r(36),{setGitAuthor:a}=r(12);e.exports={validateGitLabInputs:async function(){s.info("Using GitLab endpoint: "+process.env.RENOVATE_ENDPOINT),process.env.RENOVATE_TOKEN||(s.error("You need to configure RENOVATE_TOKEN for your bot account"),process.exit(0));try{const e=n.resolve(process.env.RENOVATE_ENDPOINT,"user"),t={headers:{"PRIVATE-TOKEN":process.env.RENOVATE_TOKEN}},r=await o(e,t).json();s.debug({user:r}),s.info("Authenticated as GitLab user: "+r.username),global.botUsername=r.username,global.botUserId=r.id,global.gitAuthor=`${r.name} <${r.email}>`,a(global.gitAuthor),await i({endpoint:process.env.RENOVATE_ENDPOINT,token:process.env.RENOVATE_TOKEN})}catch(e){s.error({err:e,body:e.response?e.response.body:void 0},"GitLab authentication failed"),process.exit(0)}}}},function(e,t){e.exports=require("renovate/dist/modules/platform/gitlab")},function(e,t,r){const{logger:o}=r(0);e.exports={validateEnv:function(){process.env.RENOVATE_PLATFORM||(o.error("Missing configuration: RENOVATE_PLATFORM"),process.exit(0));process.env.RENOVATE_ENDPOINT||(o.error("You must configure RENOVATE_ENDPOINT"),process.exit(0));process.env.RENOVATE_ENDPOINT=process.env.RENOVATE_ENDPOINT.replace(/[^/]$/,"$&/"),o.info(`Trying ${process.env.RENOVATE_PLATFORM} platform: ${process.env.RENOVATE_ENDPOINT}`)}}},function(e,t,r){const{logger:o}=r(0),n=r(39);e.exports={validateLicense:function(){if(process.env.WS_PLATFORM)return void o.info("This software is licensed for Mend Remediate customers only");o.debug("Validating license key"),process.env.LICENSE_KEY||(o.error("You must configure a Mend License Key in LICENSE_KEY environment variable. Visit https://renovate.whitesourcesoftware.com/on-premises/ to obtain your key."),process.exit(0));let e,t;try{const[r,s]=process.env.LICENSE_KEY.split("."),i=new n.KJUR.crypto.Signature({alg:"SHA1withECDSA",prov:"cryptojs/jsrsa"});i.init({xy:"0464689deec8e42e79d3a7a2a680636959d96c152f587cbd1cf9e3fe11ec0b2631150b2cc6204d54da6e2c71f750857e7bb58c9f566370579c3325addb78a68e8e",curve:"secp256r1"}),i.updateString(r),o.debug("Verifying LICENSE_KEY"),e=i.verify(s),t=JSON.parse(Buffer.from(r,"base64").toString())}catch(e){o.debug({err:e},"Error decoding license key")}e||(o.error("Failed to decode LICENSE_KEY."),process.exit(0));"y"!==process.env.ACCEPT_WHITESOURCE_TOS&&(o.error("You must accept the Mend Terms of Service to run this image. Check the documentation for ACCEPT_WHITESOURCE_TOS"),process.exit(0));const{name:r,email:s,company:i}=t;i?o.info(`This is a CORPORATE Mend Renovate license, registered to: ${i}. It was registered by ${r} (${s})`):o.info(`This is a PERSONAL Mend Renovate license, registered to: ${r} (${s})`)}}},function(e,t){e.exports=require("jsrsasign")},function(e,t,r){const{logger:o}=r(0),n=r(41),s=r(43),i=r(46),a=r(47),u=r(48),c=r(49);let l=null;e.exports={getWebhooksStatus:function(){return{webhooks:{lastWebhookReceived:l}}},startWebhooksListener:async function(e,t){if(global.remediateServerUrl)return void o.debug("Skipping webhook listener as in worker mode");o.debug("Starting webhook listener");const r={};function p(e,t,r){const p=e.headers["ws-log-context"];p&&o.debug({logContext:p},"Webhook received"),l=new Date;try{if(e.headers["x-github-event"])n.githubWebhookHandler(e,t);else if(e.headers["x-gitlab-event"])s.gitlabWebhookHandler(e,t);else if(e.headers["x-event-key"])"bitbucket"===process.env.WS_PLATFORM?a.bitbucketWebhookHandler(e,t):i.bitbucketWebhookHandler(e,t);else if(e.headers["x-vss-subscriptionid"])c.azureWebhookHandler(e,t);else{if(!e.headers["ws-component"])return o.info({logContext:p,headers:e.headers,body:e.body},"Unknown webhook"),r();u.whitesourceWebhookHandler(e,t)}return Promise.resolve()}catch(e){return o.error({logContext:p,err:e,message:e.message,stack:e.stack},"Error thrown processing webhook"),t.sendStatus(500)}}process.env.DATABASE_URL&&(r.connectionString=process.env.DATABASE_URL),"github"===process.env.RENOVATE_PLATFORM?n.init():"gitlab"===process.env.RENOVATE_PLATFORM?await s.init(t):"azure"===process.env.RENOVATE_PLATFORM?c.init():i.init(),e.post("/webhook",(e,t,r)=>p(e,t,r)),e.post("/renovate-webhook",(e,t,r)=>p(e,t,r))}}},function(e,t,r){const o=r(42),n=r(4),{logger:s}=r(0),{enqueueRepos:i,dequeueRepos:a,deleteInstallationJobs:u}=r(2);function c(e,t,r){global.repoVerboseList=global.repoVerboseList||[],e.forEach(e=>{const o={repository:e.full_name,id:e.id,accountId:t,installationId:r};global.repoVerboseList.push(o)})}e.exports={init:function(){s.debug("Initialized GitHub webhook handler")},githubWebhookHandler:function(e,t){function r(e){t.status(400).send({error:e})}const l=e.body;s.trace({payload:l},"Event payload");if(!e.headers["x-github-delivery"])return r("No id found in the request");const p=e.headers["x-github-event"];if(!p)return r("No event found in the request");if("null"!==process.env.WEBHOOK_SECRET){const t=e.headers["x-hub-signature"]||"";if(!t)return r("No signature found in the request");if(d=process.env.WEBHOOK_SECRET||"renovate",g=JSON.stringify(l),f=t,!o(Buffer.from(f),Buffer.from(function(e,t){return"sha1="+n.createHmac("sha1",e).update(t).digest("hex")}(d,g))))return r("Failed to verify signature")}var d,g,f;const b=function(e,t){const{action:r}=t,{id:o}=t.installation||{},{full_name:n}=t.repository||{};if(["integration_installation","integration_installation_repositories"].includes(e))return s.trace({repository:n},"Discarding event type: "+e),null;if(s.debug({event:e,action:r,installationId:o,repository:n},"Received webhook event"),"installation"===e){if("created"===r){const e=t.installation.account.accountId||t.installation.account.id;c(t.repositories,e,t.installation.id);const r=t.repositories.map(e=>e.full_name);return{task:"enqueue",installationId:o,repositories:r,reason:"installed"}}return"deleted"===r?(global.repoVerboseList=global.repoVerboseList?global.repoVerboseList.filter(e=>e.installationId!==o):[],{task:"uninstall",installationId:o}):(s.warn({installationId:o},"Unknown installation action: "+r),null)}if("installation_repositories"===e){if("added"===r){const e=t.installation.account.accountId||t.installation.account.id;c(t.repositories_added,e,t.installation.id);const r=t.repositories_added.map(e=>e.full_name);return{task:"enqueue",installationId:o,repositories:r,reason:"repositories-added"}}if("removed"===r){global.repoVerboseList=global.repoVerboseList||[],t.repositories_removed.forEach(e=>{global.repoVerboseList=global.repoVerboseList.filter(t=>t.id!==e.id)});const e=t.repositories_removed.map(e=>e.full_name);return{task:"dequeue",installationId:o,repositories:e}}return s.warn({installationId:o},"Unknown installation_repositories action: "+r),null}if("pull_request"===e){if(!(t.pull_request.user.login===global.botUsername))return s.debug({repository:n},"Ignoring non-Bot PR event"),null;if("closed"===r){if(!!t.pull_request.merged_at){const e=t.pull_request.merged_by&&t.pull_request.merged_by.login===global.botUsername;return{task:"enqueue",installationId:o,repository:n,reason:e?"automerge":"manual-pr-merge"}}if(t.pull_request.title.endsWith("- autoclosed"))return s.debug({repository:n},"Ignoring PR autoclose event"),null;return{task:"enqueue",installationId:o,repository:n,reason:"manual-pr-close"}}if("edited"===r&&t.changes&&t.changes.title&&t.pull_request.title.startsWith("rebase!")){return{task:"enqueue",installationId:o,repository:n,reason:"rebase-request"}}if("labeled"===r&&"rebase"===t.label.name){return{task:"enqueue",installationId:o,repository:n,reason:"rebase-request"}}if("edited"===r&&t.changes&&t.changes.body&&(t.pull_request.body.includes("- [x] \x3c!-- renovate-rebase --\x3e")||t.pull_request.body.includes("- [x] \x3c!-- rebase-check --\x3e")||t.pull_request.body.includes("- [x] \x3c!-- whitesource-remediate-rebase --\x3e"))){return{task:"enqueue",installationId:o,repository:n,reason:"rebase-request"}}return s.debug({repository:n},"Ignoring pull_request action: "+r),null}if("issues"===e){const e=t.issue.user.login;if(!(e===global.botUsername))return s.debug({repository:n,botUsername:global.botUsername,issueCreator:e},"Ignoring event for a GitHub issue created by someone else"),null;if(t.issue.body&&t.issue.body.includes("<REMEDIATE>")){return{task:"enqueue",installationId:o,repository:n,reason:"remediate"}}if("edited"===r&&t.changes&&t.changes.body&&t.issue.body.includes("- [x] \x3c!--")){return{task:"enqueue",installationId:o,repository:n,reason:"master-issue-check"}}return s.debug({repository:n},"Ignoring issue action: "+r),null}if("push"===e){const e=t.ref.replace("refs/heads/","");if(t.pusher.name===global.botUsername)return s.debug({repository:n,branch:e},"Ignoring non-bot commit"),null;if("0000000000000000000000000000000000000000"===t.after)return s.debug({repository:n,branch:e},"Ignoring onboarding branch deletion"),null;if("renovate/configure"===e||"whitesource-remediate/configure"===e){return{task:"enqueue",installationId:o,repository:n,reason:"onboarding-update"}}if("master"===e||"main"===e||"develop"===e){if(!t.commits.some(e=>{const t=e.added.concat(e.removed).concat(e.modified);return t.includes(".whitesource")||t.includes("renovate.json")||t.includes("package.json")||t.includes("go.mod")||t.includes("Dockerfile")||t.includes("WORKSPACE")||t.includes(".nvmrc")||t.some(e=>e.endsWith("/package.json"))||t.some(e=>e.endsWith("/package.js"))||t.some(e=>e.endsWith("/Dockerfile"))}))return s.debug({repository:n},"Ignoring unimportant commits to master"),null;return{task:"enqueue",installationId:o,repository:n,reason:"master-commit"}}if(e.startsWith("renovate/")||e.startsWith("whitesoure-remediate/")){return{task:"enqueue",installationId:o,repository:n,reason:"pr-update"}}return s.debug({repository:n},"Ignoring unimportant push event"),null}return s.debug({repository:n},"Ignoring event type: "+e),null}(p,l);if(!b)return t.sendStatus(200);if(s.info({result:b},"Event result"),"enqueue"===b.task){const t=b.repositories||[b.repository],r=t.map(e=>({repository:e,uniqueKey:e})),o=t.map(()=>b.installationId);i(e.headers["ws-log-context"],b.reason,r,o)}else"dequeue"===b.task?a(b.repositories):"uninstall"===b.task?u(b.installationId):s.error("Unknown event result");return t.sendStatus(200)}}},function(e,t){e.exports=require("buffer-equal-constant-time")},function(e,t,r){const{logger:o}=r(0),n=r(3),s=r(1),i=r(44),a=r(45),{enqueueRepos:u,dequeueRepos:c}=r(2);e.exports={init:async function(e){let t;try{let r=n.resolve(process.env.RENOVATE_ENDPOINT,"projects?membership=true&per_page=100&min_access_level=30"),u=[];do{const e={headers:{"PRIVATE-TOKEN":process.env.RENOVATE_TOKEN},responseType:"json"},t=await s(r,e);u=u.concat(t.body);const o=a(t.headers.link);r=o&&o.next?o.next.url:null}while(r);o.info("Discovered reposistory count: "+u.length),t=u.map(e=>({id:e.id,repository:e.path_with_namespace,isPrivate:"private"===e.visibility})),o.trace({config:t},"All repos"),t.length&&e.autodiscoverFilter&&(o.info("Applying autodiscoverFilter"),t=t.filter(t=>i(t.repository,e.autodiscoverFilter)),o.trace({config:t},"Finished applying autodiscoverFilter"),t.length||o.info("None of the discovered projects matched the filter")),o.info({allRepos:t},"Repository list for integration"),l=new Set(t.map(e=>e.repository))}catch(e){if(e.statusCode&&e.statusCode>=500&&e.statusCode<600)return void o.warn({err:e},"Error reaching GitLab. Scheduler could not run.");o.error({err:e,message:e.message},"Unknown gitlabScheduler error")}o.info("Initialized GitLab webhook handler")},gitlabWebhookHandler:function(e,t){function r(e){t.status(400).send({error:e})}if("null"!==process.env.WEBHOOK_SECRET){const t=e.headers["x-gitlab-token"]||"";if(!t)return r("No token found in the request");const n=process.env.WEBHOOK_SECRET||"renovate";if(t!==n)return o.info("Discarding webhook with incorrect secret: "+t),r("Failed to verify token")}const n=e.headers["x-gitlab-event"];if(!n)return r("No event found in the request");const s=e.body,i=function(e,t){o.trace({eventDescription:e,payload:t},"processEvent");let{path_with_namespace:r}=t.project||{};r=r||t.project_path_with_namespace;const n=t.event_name||t.event_type;if(!r){const e=t;return e.key&&(e.key="**************"),o.info({modifiedPayload:e},"Ignoring event with no repository"),null}if(!l.has(r)&&"issue"!==n&&"confidential_issue"!==n&&"user_add_to_team"!==t.event_name)return o.info("Ignoring non-installed repo"),null;return p(t,r)}(n,s);if(!i)return t.sendStatus(200);o.info({result:i},"Event result"),"enqueue"===i.task?u(e.headers["ws-log-context"],i.reason,[{repository:i.repository,uniqueKey:i.repository}]):"dequeue"===i.task?c([i.repository]):o.error("Unknown event result");return t.sendStatus(200)},getEventResult:p};let l=new Set;function p(e,t){const r=e.event_name||e.event_type;if(["project_create","project_destroy","project_rename","project_transfer","project_update","user_create","user_destroy","user_failed_login","user_rename","key_create","key_destroy","group_create","group_destroy","group_rename","user_add_to_group","user_remove_from_group","tag_push","repository_update"].includes(r))return o.trace("Discarding event type: "+r),null;if(o.info({event:r,repository:t},"Received webhook event"),"user_add_to_team"===r){if(e.user_id!==global.botUserId)return o.info("Ignoring non-bot team addition"),null;const r=e.access_level;return"Guest"===r||"Reporter"===r?(o.warn({repository:t,accessLevel:r},"Bot was added to project with insufficient permissions"),null):(l.add(t),{task:"enqueue",repository:t,reason:"repositories-added"})}if("user_remove_from_team"===r)return e.user_id!==global.botUserId?(o.info("Ignoring non-bot user removal"),null):(l.delete(t),{task:"dequeue",repository:t});if("issue"===r||"confidential_issue"===r){const r=e.object_attributes.author_id;if(!(r===global.botUserId))return o.debug({repository:t,issueAuthor:r},"Ignoring issue because it is not our bot issue"),null;if(e.changes&&e.changes.description&&e.changes.description.current.includes("- [x] \x3c!--"))return o.info("Enqueuing job because master issue has been checked"),{task:"enqueue",repository:t,reason:"master-issue-check"};if(e.changes&&e.changes.description&&e.changes.description.current.includes("<REMEDIATE>"))return o.info("Enqueuing job because issue contains Remediate data"),{task:"enqueue",repository:t,reason:"remediate"};o.info("Ignoring bot issue that does not contain Remediate data")}if("merge_request"===r){const r=e.object_attributes.author_id;if(!(r===global.botUserId))return o.info({repository:t,mrAuthor:r},"Ignoring non-bot MR event"),null;const{action:n,state:s}=e.object_attributes,i=e.user.username===global.botUsername;if("merge"===n)return{task:"enqueue",repository:t,reason:i?"automerge":"manual-pr-merge"};if("close"===n)return i?(o.info({repository:t},"Ignoring MR autoclose event"),null):{task:"enqueue",repository:t,reason:"manual-pr-close"};if("update"===n){if("closed"===s&&e.changes&&e.changes.title&&e.changes.title.previous!==e.changes.title.current)return{task:"enqueue",repository:t,reason:"closed-pr-rename"};if("opened"===s&&e.changes&&e.changes.title&&e.changes.title.current&&e.changes.title&&e.changes.title.current.startsWith("rebase!"))return{task:"enqueue",repository:t,reason:"rebase-request"};if("opened"===s&&e.changes&&e.changes.labels&&e.changes.labels.current&&e.changes.labels.current.some(e=>"rebase"===e.title))return{task:"enqueue",repository:t,reason:"rebase-request"};if("opened"===s&&e.changes&&e.changes.description&&(e.changes.description.current.includes("- [x] \x3c!-- renovate-rebase --\x3e")||e.changes.description.current.includes("- [x] \x3c!-- rebase-check --\x3e")||e.changes.description.current.includes("- [x] \x3c!-- whitesource-remediate-rebase --\x3e"))){return{task:"enqueue",repository:t,reason:"rebase-request"}}return o.info("Ignoring unimportant MR update"),null}return o.info("Ignoring unimportant MR action: "+n),null}if("push"===r){const r=e.ref.replace("refs/heads/","");if(e.user_id===global.botUserId)return o.info({repository:t,branch:r},"Ignoring bot commit"),null;if("0000000000000000000000000000000000000000"===e.after)return o.info({repository:t,branch:r},"Ignoring onboarding branch deletion"),null;if("renovate/configure"===r||"whitesource-remediate/configure"===r)return{task:"enqueue",repository:t,reason:"onboarding-update"};if("master"===r||"main"===r||"develop"===r){return e.commits.some(e=>{const t=e.added.concat(e.removed).concat(e.modified);return t.includes("renovate.json")||t.includes("package.json")||t.includes("go.mod")||t.includes("Dockerfile")||t.includes("WORKSPACE")||t.includes(".nvmrc")||t.includes(".whitesource")||t.some(e=>e.endsWith("/package.json"))||t.some(e=>e.endsWith("/package.js"))||t.some(e=>e.endsWith("/Dockerfile"))})?{task:"enqueue",repository:t,reason:"master-commit"}:(o.info({repository:t},"Ignoring unimportant commits to master"),null)}return r.startsWith("renovate/")||r.startsWith("whitesource-remediate/")?{task:"enqueue",repository:t,reason:"pr-update"}:(o.info({repository:t},"Ignoring unimportant push event"),null)}return o.info({repository:t},"Ignoring event type: "+r),null}},function(e,t){e.exports=require("minimatch")},function(e,t){e.exports=require("parse-link-header")},function(e,t,r){const{logger:o}=r(0),{enqueueRepos:n,dequeueRepos:s}=r(2);function i(e,t){const r=e.eventKey;if([].includes(r))return o.trace("Discarding event type: "+r),null;if(o.info({event:r,repository:t},"Received webhook event"),r.startsWith("issue:")){const r=e.actor.user;return r===global.botUsername?e.issue&&e.issue.body&&e.issue.body.includes("<REMEDIATE>")?{task:"enqueue",repository:t,reason:"remediate"}:(o.info("Ignoring unimportant bot issue event"),null):(o.info({repository:t,issueAuthor:r,botUserId:global.botUserId},"Ignoring non-bot issue event"),null)}if(r.startsWith("pullrequest:")){const r=e.pullRequest.author.user;return r===global.botUsername?{task:"enqueue",repository:t,reason:"pr-update"}:(o.info({repository:t,prAuthor:r,botUserId:global.botUserId},"Ignoring non-bot PR event"),null)}return o.info({repository:t},"Ignoring unknown event type: "+r),null}e.exports={init:function(){o.info("Initialized Bitbucket webhook handler")},bitbucketWebhookHandler:function(e,t){function r(e){t.status(400).send({error:e})}const a=(e.headers.authorization||"").replace("Bearer ","");if(!a.length)return r("No token found in the request");const u=process.env.RENOVATE_PASSWORD;if(a!==u)return o.info("Discarding webhook with incorrect secret"),r("Failed to verify token");const c=e.body.eventKey;if(!c)return r("No event found in the request");const l=e.body,p=function(e,t){let r;o.trace({eventDescription:e,payload:t},"processEvent"),t.repository&&t.repository.project&&t.repository.project.key&&(r=t.repository.project.key+"/"+t.repository.slug);if(!r)return o.info({payload:t},"Ignoring event with no repository"),null;return i(t,r)}(c,l);if(!p)return t.sendStatus(200);o.info({result:p},"Event result"),"enqueue"===p.task?n(e.headers["ws-log-context"],p.reason,[{repository:p.repository,uniqueKey:p.repository}]):"dequeue"===p.task?s([p.repository]):o.error("Unknown event result");return t.sendStatus(200)},getEventResult:i}},function(e,t,r){const{logger:o}=r(0),{enqueueRepos:n,dequeueRepos:s}=r(2),i=["repo:commit_status_created"];function a(e,t){const r=e.event;if(i.includes(r))return o.trace("Discarding event type: "+r),null;if(o.info({event:r,repository:t},"Received webhook event"),r.startsWith("pullrequest:")){const r=e.data.pullrequest.source.branch.name;return r.startsWith("whitesource-remediate")||o.info({repository:t,branchName:r,botUserId:global.botUserId},"Ignoring non-bot PR event"),null}return o.info({repository:t},"Ignoring unknown event type: "+r),null}e.exports={init:function(){o.info("Initialized Bitbucket webhook handler")},bitbucketWebhookHandler:function(e,t){function r(e){t.status(400).send({error:e})}if(!(e.headers.authorization||"").replace("JWT ","").length)return r("No token found in the request");const i=e.body.event;if(!i)return r("No event found in the request");const u=e.body,c=e.headers["ws-scm-installation-id"],l=e.headers["ws-scm-app-key"],p=function(e,t){let r;o.trace({eventDescription:e,payload:t},"processEvent"),t.data.repository&&t.data.repository.project&&t.data.repository.project.key&&(r=t.data.repository.full_name);if(!r)return o.info({payload:t},"Ignoring event with no repository"),null;return a(t,r)}(i,u);if(!p)return t.sendStatus(200);o.info({result:p},"Event result"),"enqueue"===p.task?n(e.headers["ws-log-context"],p.reason,[{repository:p.repository,uniqueKey:p.repository}],[c],{appKey:l}):"dequeue"===p.task?s([p.repository]):o.error("Unknown event result");return t.sendStatus(200)},getEventResult:a}},function(e,t,r){const{logger:o}=r(0),n=r(4),{enqueueRepos:s}=r(2);e.exports={whitesourceWebhookHandler:function(e,t){function r(e){t.status(400).send({error:e})}const i=e.body;if(o.trace({payload:i},"Event payload"),"null"!==process.env.WEBHOOK_SECRET){const t=e.headers.webhook_secret||"";if(!t)return r("No signature found in the request");if(process.env.WEBHOOK_SECRET!==t)return r("Failed to verify signature")}const a=function(e,t){const{repository:r,installationId:s}=e;if(r){o.debug({installationId:s,repository:r},"Received webhook event");const i=e.isScheduled?"scheduled":"remediate";if("azure"===process.env.WS_PLATFORM){const o=e.collectionId,n=e.accountId,a=e.repositoryId,u=`${e.installationId}/${r}`;return{task:"enqueue",repository:r,uniqueKey:u,reason:i,collection:s,installationId:o,accountId:n,repoId:a,vaultKey:t["ws-secret-name"]}}const a={task:"enqueue",repository:r,uniqueKey:r,reason:i,installationId:s,repoId:e.repositoryId};return"bitbucket"===process.env.WS_PLATFORM&&(a.vaultKey="BB-"+n.createHash("SHA1").update(s).digest("hex"),a.installationId=t["ws-scm-installation-id"],a.appKey=t["ws-scm-app-key"]),a}return null}(i,e.headers);if(!a)return t.sendStatus(200);o.info({result:a},"Event result"),"enqueue"===a.task?s(e.headers["ws-log-context"],a.reason,[{repository:a.repository,uniqueKey:a.uniqueKey}],[a.installationId],{vaultKey:a.vaultKey,collection:a.collection,collectionId:a.installationId,accountId:a.accountId,repoId:a.repoId,appKey:a.appKey}):o.error("Unknown event result");return t.sendStatus(200)}}},function(e,t,r){const{logger:o}=r(0),n=r(4),{enqueueRepos:s,dequeueRepos:i}=r(2);e.exports={init:function(){o.debug("Initialized Azure webhook handler")},azureWebhookHandler:function(e,t){const r=e.body;function a(e){return t.status(400).send({error:e})}const u=r.eventType;if(!u)return a("No event found in the request");const c=function(e){const[,t]=e.split(" "),r=Buffer.from(t,"base64"),[,o]=r.toString("ascii").split(":");return o}(e.headers.authorization);if(!c)return a("No secret found in the request");const l=e.body.resource.repository.project.id;if(!c)return a("No project id found in the request");const p=n.createHash("sha1").update(l).digest("hex");if(c!==p.toString())return o.info("Discarding webhook with incorrect secret: "+c),a("Failed to verify secret");const d=function(e,t,r){o.trace({payload:t},"processEvent");const n=t.eventType;if(!["git.push","git.pullrequest.updated","git.pullrequest.created"].includes(n))return o.trace({payload:t},"Discarding event type: "+n),null;const s=t.resourceContainers.collection.baseUrl.replace("https://dev.azure.com/","").replace("/",""),i=t.resource.repository.project.name,a=t.resource.repository.id,u=t.resource.repository.name,c=t.resourceContainers.collection.id,l=t.resource.repository.project.id,p=`${i}/${u}`,d=`${s}/${i}/${u}`;if("git.pullrequest.created"===e||"git.pullrequest.updated"===e){if(!r===t.resource.createdBy.id)return o.debug({repository:p},"Ignoring non-Bot PR event"),null;if("completed"===t.resource.status&&"succeeded"===t.resource.mergeStatus){const e=t.resource.closedBy.id===r;return{task:"enqueue",repository:p,uniqueKey:d,reason:e?"automerge":"manual-pr-merge",collection:s,collectionId:c,accountId:l,repoId:a}}if("abandoned"===t.resource.status){if(t.resource.title.endsWith("- autoclosed"))return o.debug({repository:p},"Ignoring PR autoclose event"),null;return{task:"enqueue",repository:p,uniqueKey:d,reason:"manual-pr-close",collection:s,collectionId:c,accountId:l,repoId:a}}if("active"===t.resource.status&&t.resource.description&&(t.resource.description.includes("- [X] \x3c!-- renovate-rebase --\x3e")||t.resource.description.includes("- [X] \x3c!-- rebase-check --\x3e")||t.resource.description.includes("- [X] \x3c!-- whitesource-remediate-rebase --\x3e"))){return{task:"enqueue",repository:p,uniqueKey:d,reason:"rebase-request",collection:s,collectionId:c,accountId:l,repoId:a}}return o.debug({repository:p},"Ignoring pull request event: "+e),null}if("git.push"===e&&t.resource.refUpdates[0].name){const e=t.resource.refUpdates[0].name.replace("refs/heads/","");if("renovate/configure"===e||"whitesource-remediate/configure"===e){return{task:"enqueue",repository:p,uniqueKey:d,reason:"onboarding-update",collection:s,collectionId:c,accountId:l,repoId:a}}if(e.startsWith("renovate/")||e.startsWith("whitesoure-remediate/")){return{task:"enqueue",repository:p,uniqueKey:d,reason:"pr-update",collection:s,collectionId:c,accountId:l,repoId:a}}}return null}(u,r,e.headers["ws-scm-user-id"]);o.info({result:d},"Azure - Process Event Result"),d&&("enqueue"===d.task?s(e.headers["ws-log-context"],d.reason,[{repository:d.repository,uniqueKey:d.uniqueKey}],[d.collectionId],{vaultKey:e.headers["ws-secret-name"],collection:d.collection,collectionId:d.collectionId,accountId:d.accountId,repoId:d.repoId}):"dequeue"===d.task?i([d.uniqueKey]):o.error("Unknown event result"));return t.sendStatus(200)}}},function(e,t,r){const o=r(14),n=r(10),s=r(15),{decryptConfig:i}=r(51),a=r(7),u=r(52),c=r(53),{setPlatformApi:l}=r(54),{logger:p,setMeta:d,setContext:g,clearProblems:f}=r(0),{GlobalConfig:b}=r(55),{initPlatform:h}=r(56),{initPlatform:m}=r(57),{setPrivateKey:v}=r(9),{DefaultAzureCredential:y}=r(16),{SecretClient:E}=r(17),R=r(1),{setHostRules:T,setMcAuthHostRule:_}=r(58),O=r(18),{nextJob:N,finishJob:k}=r(2);let A,I=null,S=!1;process.on("SIGTERM",()=>{p.info("Received SIGTERM"),S=!0,global.jobTimeoutCheck&&clearTimeout(global.jobTimeoutCheck)});let w,P=null,V=null,x=null,q=null;async function L(){if(q){(new Date).getTime()-q.getTime()>w&&(p.fatal({currentJob:x,currentJobStart:q,jobTimeoutMs:w},"Job timeout - exiting to allow container restart"),await k(x),process.exit(1))}global.jobTimeoutCheck=setTimeout(L,w)}async function D(e,t){let r=null;try{const t=new y,o=new E(process.env.AZURE_KEYVAULT_LOCATION,t);r=(await o.getSecret(e)).value,p.info("Successfully obtained api key from Azure keyvault"),p.trace({keyVaultToken:r},"apiToken")}catch(e){p.error(e.message),p.error("Unable to access azure keyvault API for "+t)}return r}async function C(e){const t=await D(e.params.vaultKey,e.repository),r=process.env.RENOVATE_ENDPOINT,o={body:"grant_type=urn:bitbucket:oauth2:jwt",headers:{"Content-Type":"application/x-www-form-urlencoded",Authorization:"JWT "+function(e,t,r){if(!e)return null;const o=Date.now()/1e3,n={iat:o,exp:o+540,sub:e,iss:t};return a.sign(n,r)}(e.installationId,e.params.appKey,t)},timeout:{request:1e4}};let n;try{n=await R.post("https://bitbucket.org/site/oauth2/access_token",o).json()}catch(e){p.debug({err:e},"Error retrieving access token from Bitbucket")}I=n.access_token,p.debug({endpoint:r,platformToken:I},"parameters for init platform for "+process.env.RENOVATE_PLATFORM),await m({endpoint:r,token:I})}async function M(){x&&(await k(x),P=x,V=q,x=null,q=null),d({}),f(),S&&(p.info("Received SIGTERM - shutting down"),process.exit(0));const e=await N();if(!e)return p.debug("No job - sleeping 5s"),await n(5e3),M();x=e,q=new Date,"azure"===process.env.WS_PLATFORM&&await async function(e){I=await D(e.params.vaultKey,e.repository);const t=process.env.RENOVATE_ENDPOINT+e.params.collection;p.debug({endpoint:t,platformToken:I},"parameters for init platform for "+process.env.RENOVATE_PLATFORM),await h({endpoint:t,token:I})}(e),"bitbucket"===process.env.WS_PLATFORM&&await C(e);const{repository:t,installationId:r,priority:a,reason:m,logContext:y}=e;d({repository:t}),y&&g(y),p.info({priority:a,reason:m},"Processing repository");let E,R=await async function(e){let t=JSON.parse(JSON.stringify(A));return t.platform=process.env.RENOVATE_PLATFORM,t.endpoint=process.env.RENOVATE_ENDPOINT,t.repository=e,t=s.filterConfig(t,"repository"),t.suppressNotifications=["deprecationWarningIssues"],t.cacheDir="/tmp/renovate/cache",t.containerbaseDir="/tmp/renovate/containerbase",t.renovateUsername=global.renovateUsername,await o.ensureDir(t.cacheDir),await o.ensureDir(t.containerbaseDir),t.localDir=`/tmp/renovate/${process.env.RENOVATE_PLATFORM}/${e}`,await o.ensureDir(t.localDir),await o.emptyDir(t.localDir),c.setNpmrc(t.npmrc),b.set(t),t.prFooter="",t}(t);l(process.env.RENOVATE_PLATFORM);try{await T(r,R,I)}catch(e){return p.debug({err:e},"Error setting hostRules - finishing"),M()}if(process.env.WS_PLATFORM){const o=await O.getRepoConfig(e,r);if(o&&o.mcJwt&&(E=o.mcJwt),!o)return p.info({repository:t},"Repository is not onboarded - skipping"),M();R=s.mergeChildConfig(R,o)}if(!1===R.enabled)return p.info({repository:t},"Repository has no work to do - finishing"),M();try{R=await i(R,R.repository)}catch(e){return p.debug({err:e},"Error decrypting config - finishing"),M()}try{await T(r,R,I),_(E)}catch(e){return p.debug({err:e},"Error setting hostRules - finishing"),M()}R.hostRules=[],v(R.gitPrivateKey);try{p.debug({repository:t},"start renovating repository"),await u.renovateRepository(R),p.debug({repository:t},"done  renovating repository")}catch(e){p.error({err:e,message:e.message,repository:t},"Error renovating repository")}return M()}e.exports={getWorkerStatus:function(){return{worker:{remediateServerEnabled:!!global.remediateServerUrl,remediateServerUrl:global.remediateServerUrl,previousJob:P,previousJobStart:V,currentJob:x,currentJobStart:q}}},startWorker:async function(e){if(global.remediateServerOnly)p.debug("Skipping worker as in server mode only");else{A=e,p.debug("Starting worker"),function(){if(!process.env.REMEDIATE_JOB_TIMEOUT_MINUTES)return;let e;try{e=parseInt(process.env.REMEDIATE_JOB_TIMEOUT_MINUTES,10)}catch(e){return void p.error("Cannot parse REMEDIATE_JOB_TIMEOUT_MINUTES")}e<30&&p.warn({jobTimeoutMinutes:e},"It is recommended to set REMEDIATE_JOB_TIMEOUT_MINUTES to at least 30"),w=60*e*1e3,L()}();try{process.env.RENOVATE_USER_AGENT=process.env.RENOVATE_USER_AGENT||process.env.WS_PLATFORM?"Mend Remediate":"Mend Renovate",p.debug("User agent = "+process.env.RENOVATE_USER_AGENT),global.remediateServerUrl&&p.info(`Using ${global.remediateServerUrl} as remediate-server url`),await M()}catch(e){p.error({err:e},"renovateRepository error"),process.exit(1)}}}}},function(e,t){e.exports=require("renovate/dist/config/decrypt")},function(e,t){e.exports=require("renovate/dist/workers/repository")},function(e,t){e.exports=require("renovate/dist/modules/datasource/npm")},function(e,t){e.exports=require("renovate/dist/modules/platform")},function(e,t){e.exports=require("renovate/dist/config/global")},function(e,t){e.exports=require("renovate/dist/modules/platform/azure")},function(e,t){e.exports=require("renovate/dist/modules/platform/bitbucket")},function(e,t,r){const o=r(3),{initPlatform:n}=r(59),s=r(60),{logger:i}=r(0),{initConfig:a}=r(61),{getInstallationToken:u}=r(13);e.exports={setHostRules:async function(e,t,r){if(s.clear(),"https://api.github.com/"!==process.env.RENOVATE_ENDPOINT&&process.env.GITHUB_COM_TOKEN&&(i.debug("Setting host rule for github.com"),s.add({hostType:"github",matchHost:"github.com",token:process.env.GITHUB_COM_TOKEN})),"github"===process.env.RENOVATE_PLATFORM){let r;i.info("Processing GitHub hostRules");try{r=await u(e),process.env.RENOVATE_TOKEN=r}catch(t){throw i.error({err:t,installationId:e},"Error getting installation token"),new Error("installation-token-error")}await n({endpoint:process.env.RENOVATE_ENDPOINT,token:"x-access-token:"+process.env.RENOVATE_TOKEN,username:global.botUsername,gitAuthor:global.gitAuthor}),i.trace({token:r},"Got repository token");const a={hostType:"github",matchHost:o.parse(process.env.RENOVATE_ENDPOINT).hostname,token:"x-access-token:"+r};i.debug({config:a},"Setting GHE hostRule"),s.add(a),i.debug("Finished setting hostRules"),t.isGitHub=!0}else if("bitbucket-server"===process.env.RENOVATE_PLATFORM)i.info("Processing Bitbucket Server hostRules"),s.add({hostType:"bitbucket-server",matchHost:o.parse(process.env.RENOVATE_ENDPOINT).hostname,username:process.env.RENOVATE_USERNAME,password:process.env.RENOVATE_PASSWORD}),t.isBitbucket=!0,t.platform="bitbucket-server";else if("bitbucket"===process.env.RENOVATE_PLATFORM){const e={hostType:"bitbucket",matchHost:o.parse(process.env.RENOVATE_ENDPOINT).hostname,token:r};i.info(e,"Processing Bitbucket hostRules"),s.add(e)}else if("azure"===process.env.RENOVATE_PLATFORM){const e={hostType:"azure",matchHost:"dev.azure.com",token:r};i.info(e,"Processing Azure hostRules"),s.add(e)}else{i.info("Processing gitlab hostRules");const e=process.env.RENOVATE_TOKEN;s.add({hostType:"gitlab",matchHost:o.parse(process.env.RENOVATE_ENDPOINT).hostname,token:e}),t.isGitLab=!0,t.platform="gitlab"}t.hostRules&&t.hostRules.forEach(e=>{i.debug({config:e},"Adding host rule"),s.add(e)})},setMcAuthHostRule:function(e){let t;if(process.env.MC_API_SECRET_STATIC)t=process.env.MC_API_SECRET_STATIC,i.debug("static token found");else{if(!e)return void i.debug("merge-confidence missing token");t=e,i.debug("mcJwt token found")}s.add({hostType:"merge-confidence",token:t});const r=process.env.RENOVATE_X_MERGE_CONFIDENCE_API_BASE_URL;i.debug({url:r},"initializing merge-confidence workflow"),a()}}},function(e,t){e.exports=require("renovate/dist/modules/platform/github")},function(e,t){e.exports=require("renovate/dist/util/host-rules")},function(e,t){e.exports=require("renovate/dist/util/merge-confidence")},function(e,t,r){const{initGitHubComEnv:o}=r(63),{initAzureDevopsEnv:n}=r(64),{initBitbucketCloudEnv:s}=r(65),{initEnterpriseEnv:i}=r(66);e.exports={init:async function(){process.env.WEBHOOK_SECRET="null","true"===process.env.REMEDIATE_SERVER_ONLY||"true"===process.env.WS_REMEDIATE_SERVER_ONLY?global.remediateServerOnly=!0:process.env.REMEDIATE_SERVER_URL?global.remediateServerUrl=process.env.REMEDIATE_SERVER_URL:process.env.WS_REMEDIATE_SERVER_URL&&(global.remediateServerUrl=process.env.WS_REMEDIATE_SERVER_URL);"github.com"===process.env.WS_PLATFORM?await o():"azure"===process.env.WS_PLATFORM?await n():"bitbucket"===process.env.WS_PLATFORM?await s():"enterprise"===process.env.WS_PLATFORM&&await i()}}},function(e,t,r){const{logger:o}=r(0),{fetchHostRulesSecretFromVault:n,azSecretClient:s}=r(8);e.exports={initGitHubComEnv:async function(){o.info("Initializing Mend Remediate for GitHub.com config"),process.env.RENOVATE_PLATFORM="github",process.env.RENOVATE_ENDPOINT="https://api.github.com/";try{const e=s(),t=(await e.getSecret(process.env.GH_APP_AZURE_KEYVAULT_SECRET)).value;o.trace({rawKey:t},"rawKey"),process.env.GITHUB_APP_KEY=t.replace(/ /g,"\n").replace(/\nRSA/g," RSA").replace(/\nPRIVATE/g," PRIVATE").replace(/\nKEY/g," KEY"),o.info("Retrieved GitHub App Key from Vault"),o.trace("massaged key = "+process.env.GITHUB_APP_KEY)}catch(e){o.error({err:e},"Error retrieving GitHub App key from Vault"),process.exit()}await n()}}},function(e,t,r){const{logger:o}=r(0),{fetchHostRulesSecretFromVault:n}=r(8);e.exports={initAzureDevopsEnv:async function(){o.info("Initializing Mend Remediate for dev.azure.com config"),process.env.RENOVATE_PLATFORM="azure",process.env.RENOVATE_ENDPOINT="https://dev.azure.com/",await n()}}},function(e,t,r){const{logger:o}=r(0),{fetchHostRulesSecretFromVault:n}=r(8);e.exports={initBitbucketCloudEnv:async function(){o.info("Initializing Mend Remediate for bitbucket.org config"),process.env.RENOVATE_PLATFORM="bitbucket",process.env.RENOVATE_ENDPOINT="https://api.bitbucket.org/",await n()}}},function(e,t,r){const o=r(3),n=r(6),s=r(14),{logger:i}=r(0),{massagePgpKey:a}=r(19),{decrypt:u}=r(67),{getProxy:c}=r(68),{readActivationKey:l}=r(69),{fetchActivationDetails:p}=r(70);function d(){return!!(process.env.WS_CONFIG_OVERRIDE&&process.env.RENOVATE_PLATFORM&&process.env.RENOVATE_ENDPOINT&&(process.env.RENOVATE_TOKEN||process.env.RENOVATE_USERNAME&&process.env.RENOVATE_PASSWORD))}e.exports={initEnterpriseEnv:async function(){if(i.info("Initializing Mend Remediate Enterprise config"),d())return void i.info("Using manual credentials and skipping activation key");try{const{decoded:e,propJson:t}=l(),r=t?c(t.properties):null,d=await p(e,r);if(process.env.RENOVATE_PLATFORM=d.platform,"github"===process.env.RENOVATE_PLATFORM){process.env.RENOVATE_ENDPOINT=d.configuration.scmApiUrl.replace(/\/?$/,"/"),process.env.GITHUB_APP_ID=d.configuration.applicationId;const t=d.configuration.privateKey.replace("encrypt:",""),r=u(e.secretKey,t);process.env.GITHUB_APP_KEY=r}else if("gitlab"===process.env.RENOVATE_PLATFORM){process.env.RENOVATE_ENDPOINT=d.configuration.scmUrl.replace(/\/?$/,"/");const t=d.configuration.accessToken.replace("encrypt:",""),r=u(e.secretKey,t);process.env.RENOVATE_TOKEN=r}else{process.env.RENOVATE_ENDPOINT=d.configuration.scmUrl.replace(/\/?$/,"/"),process.env.RENOVATE_ENDPOINT.startsWith("http://")?process.env.RENOVATE_GIT_FS="http":process.env.RENOVATE_GIT_FS="https",process.env.RENOVATE_USERNAME=d.configuration.user;const t=d.configuration.accessToken.replace("encrypt:",""),r=u(e.secretKey,t);process.env.RENOVATE_PASSWORD=r}const g="gitlab"===process.env.RENOVATE_PLATFORM?"http://wss-gls-app:5678":"http://wss-ghe-app:5678",f=t&&t.properties.find(e=>"controller.url"===e.propertyName);if(process.env.WS_CONTROLLER_DESTINATION_URL||(process.env.CONTROLLER_DESTINATION_URL?process.env.WS_CONTROLLER_DESTINATION_URL=process.env.CONTROLLER_DESTINATION_URL:process.env.WS_CONTROLLER_DESTINATION_URL=f&&f.propertyValue?f.propertyValue:g),i.info({controllerUrl:process.env.WS_CONTROLLER_DESTINATION_URL},"Successfully retrieved controllerUrl from Mend Enterprise config"),process.env.HTTP_PROXY||process.env.HTTPS_PROXY){n.string(process.env.NO_PROXY)?(i.debug("Using NO_PROXY found in env"),process.env.MEND_PROXY_ALL&&i.warn("Be aware that proxy.for.all setting will be ignored as a custom NO_PROXY is already defined")):process.env.MEND_PROXY_ALL?(i.debug("Proxying all"),process.env.NO_PROXY=""):(i.debug("Setting code platform in NO_PROXY"),process.env.NO_PROXY=o.parse(process.env.RENOVATE_ENDPOINT).hostname);const e=process.env.NO_PROXY.split(",").filter(Boolean),t=o.parse(process.env.WS_CONTROLLER_DESTINATION_URL).hostname;e.includes(t)||(i.debug("Adding controller to NO_PROXY"),e.push(t)),process.env.REMEDIATE_SERVER_URL&&(i.debug("Adding remediate-server to NO_PROXY"),e.push(o.parse(process.env.REMEDIATE_SERVER_URL).hostname)),process.env.WS_REMEDIATE_SERVER_URL&&(i.debug("Adding remediate-server to NO_PROXY"),e.push(o.parse(process.env.WS_REMEDIATE_SERVER_URL).hostname)),process.env.NO_PROXY=e.join(","),i.info({HTTP_PROXY:process.env.HTTP_PROXY,HTTPS_PROXY:process.env.HTTPS_PROXY,NO_PROXY:process.env.NO_PROXY},"Initializing global proxy")}if(n.string(process.env.WS_HOST_RULES_PRIVATE_KEY))i.info("Detected  key for use in config decryption"),process.env.RENOVATE_PRIVATE_KEY=a(process.env.WS_HOST_RULES_PRIVATE_KEY);else if(n.string(process.env.WS_HOST_RULES_PRIVATE_KEY_FILE_PATH)){let e;try{e=await s.readFile(process.env.WS_HOST_RULES_PRIVATE_KEY_FILE_PATH,"utf8")}catch(e){i.warn({err:e,path:process.env.WS_HOST_RULES_PRIVATE_KEY_FILE_PATH},"Error reading private key from disk")}e?(i.info("Read PGP key from file"),process.env.RENOVATE_PRIVATE_KEY=a(e)):(i.error("Could not read private key - exiting"),process.exit())}else i.info("No GPG key"),delete process.env.RENOVATE_PRIVATE_KEY}catch(e){i.error({err:e},"Error retrieving Mend config"),process.exit()}}}},function(e,t,r){const o=r(4);e.exports={decrypt:function(e,t){const r=Buffer.from(""),n=o.createHash("SHA1").update(e).digest().slice(0,16),s=o.createDecipheriv("aes-128-ecb",n,r);return s.update(t,"base64","utf8")+s.final("utf8")}}},function(e,t,r){const{logger:o}=r(0);e.exports={getProxy:function(e){const t=e.find(e=>"proxy.host"===e.propertyName),r=t&&t.propertyValue;if(!r||!r.length)return o.info("No proxy defined."),null;const n=e.find(e=>"proxy.for.all.param"===e.propertyName);n&&"true"===n.propertyValue.toString()?(o.debug("proxy.for.all is true"),process.env.MEND_PROXY_ALL=!0):o.debug("proxy.for.all is false");let s=r;s.match(/https?:\/\//)||(o.debug("No http prefix found. Adding http:// prefix to proxy"),s="http://"+s);const i=e.find(e=>"proxy.port"===e.propertyName),a=i&&i.propertyValue;a&&a.length?s+=":"+a:o.debug("Warning: found proxy host but not proxy port");const u=e.find(e=>"proxy.user"===e.propertyName),c=u&&u.propertyValue;if(!c||!c.length)return o.debug("No proxy user defined"),s;s=s.replace("://",`://${c}@`);const l=e.find(e=>"proxy.password"===e.propertyName),p=l&&l.propertyValue;if(!p||!p.length)return o.debug("Warning: No proxy password defined"),s;return s=s.replace(c,`${c}:${p}`),s}}},function(e,t,r){const o=r(11),n=r(7),{logger:s}=r(0);function i(e){return e.charCodeAt(0)-4}e.exports={readActivationKey:function(){let e=process.env.WS_ACTIVATION_KEY||process.env.W4D_BOLT_OP_ACTIVATION_KEY;e&&s.info("Read activation key from env");const t=process.env.WS_PROP_JSON_FILE_PATH||process.env.WS_PROP_JSON||"/etc/usr/local/whitesource/conf/prop.json";let r,a;try{s.debug("Attempting to read prop.json file from "+t),r=o.readFileSync(t,"utf8")}catch(n){s.debug("Could not read "+t);try{s.debug("Attempting to read prop.json file from /etc/whitesource/prop.json"),r=o.readFileSync("/etc/whitesource/prop.json","utf8"),s.warn("/etc/whitesource/prop.json is now deprecated. Please use /etc/usr/local/whitesource/conf/prop.json instead")}catch(t){e||(s.error("Could not locate prop.json config file - exiting"),process.exit()),s.debug("Could not read /etc/whitesource/prop.json either. Skipping prop.json and reading from env instead.")}}if(r){try{a=JSON.parse(r),s.debug("Parsed prop.json file")}catch(e){s.error({err:e},"Cannot parse prop.json file"),process.exit()}if(a.properties||(s.error('Cannot find "properties" field of prop.json'),process.exit()),!e){let t;try{t=a.properties.find(e=>"bolt.op.activation.key"===e.propertyName),t||(s.error('Cannot find "bolt.op.activation.key" object in properties'),process.exit()),s.debug("Found activation key object")}catch(e){s.error('Error finding "bolt.op.activation.key" object in properties'),process.exit()}t.propertyValue||(s.error("Cannot find propertyValue of activation key"),process.exit()),s.info("Read activation key from prop.json"),e=t.propertyValue}}const u=e.replace(/\\\\/g,"\\");let c;try{s.debug("Massaging activation key");const e=u.split("").map(i);let t="";e.forEach(e=>{var r;t+=(r=e,String.fromCharCode(r))}),t=t.split("").reverse().join("");const r=Buffer.from(t,"base64");c=r.toString("ascii");const o=n.verify(c,"whiteSourceSecret");return s.debug("Decoded activation key"),{decoded:o,propJson:a}}catch(e){s.debug({activationKey:u,text:c,err:e},"Activation decode error"),s.error("Cannot decode activation key"),process.exit()}return{}}}},function(e,t,r){const o=r(1),n=r(71),{logger:s}=r(0),i=r(3);e.exports={fetchActivationDetails:async function e(t,r,a="github"){s.debug(`fetchActivatioDetails(platform=${a})`);const u={};r&&(s.info("Found proxy configuration in prop.json: "+r),process.env.HTTP_PROXY?s.info("Found HTTP_PROXY configuration in env - using it instead"):(s.debug("Setting HTTP_PROXY: "+r),process.env.HTTP_PROXY=r),process.env.HTTPS_PROXY?s.info("Found HTTPS_PROXY configuration in env - using it instead"):(s.debug("Setting HTTPS_PROXY: "+r),process.env.HTTPS_PROXY=r));const c=process.env.HTTPS_PROXY||process.env.HTTP_PROXY;if(c){s.debug("Querying WSS server using proxy: "+c);const e=i.parse(c),t={};let r;t.host=e.hostname,t.port=e.port,t.proxyAuth=e.auth,s.debug({proxy:t},"Proxy details"),"http:"===e.protocol?(s.debug("Tunneling https over http"),r=n.httpsOverHttp({proxy:t})):(s.debug("Tunneling https over https"),r=n.httpsOverHttps({proxy:t})),u.agent={https:r}}const l=t.wsEnvIdentifier.replace("/api","/internal/v1.0");s.debug("Trying URL: "+l);let p;u.json={requestType:"getAgentConfiguration",userKey:t.userKey,orgToken:t.orgToken,agentType:{github:"bolt-4-op-github-scanner",gitlab:"bolt-4-op-gitlab-scanner","bitbucket-server":"bolt-4-op-bitbucket-scanner"}[a],agentVersion:"19.2.2",configVer:t.confVer};try{p=await o.post(l,u).json()}catch(e){s.debug({err:e},"Error retrieving from Mend server")}p||(s.error("Cannot retrieve details from Mend server"),process.exit());if(p.message&&p.message.startsWith("No configuration")){const o={github:"bitbucket-server","bitbucket-server":"gitlab"}[a];if(o)return s.debug("Trying "+o),e(t,r,o);s.error("No configuration found - exiting"),process.exit()}return{...p,platform:a}}}},function(e,t){e.exports=require("tunnel")},function(e,t,r){const o=r(1),{logger:n}=r(0);e.exports={filterInstallations:async function(e){if("github.com"!==process.env.WS_PLATFORM)return e;const t=process.env.BOLT_SERVER_DESTINATION_URL.replace(/\/?$/,""),r=[];for(const s of e){const e=s.id,i=`${t}/bolt4gh/operation/gitHubApp/installationId/${e}`;try{const e=await o(i,{timeout:{request:1e4}}).json();"EXISTING_WS_ORG"===e.registrationType?"SUCCESS"===e.registrationResult?(n.debug({installation:s},"Found valid installation: "+s.login),r.push(s)):n.debug({installation:s},"Installation has wrong registrationResult: "+e.registrationResult):n.debug({installation:s},"Installation has wrong registrationType: "+e.registrationType)}catch(e){n.debug({err:e,installation:s},"Installation not allowed")}}return n.info(r.length+" allowed installations"),r}}},function(e,t,r){const{mergeChildConfig:o}=r(15),{logger:n}=r(0),{getRepoDotWhiteSourceConfig:s,getRemediateConfig:i}=r(74),{processRemediateIssues:a}=r(75);e.exports={getRepoConfig:async function(e,t){const r=e.repository;n.debug({repository:r},"Retrieving remediate repository config");try{let u=i();const c=await s(r,t);if(!c)return void n.debug("No config - skipping repository");let l;u=o(u,c);try{l=await a(u,e)}catch(e){return void n.error({err:e},"Error getting issues - aborting repo job")}return u=o(u,l),!0===u.enableRenovate||"true"===u.enableRenovate?(delete u.enableRenovate,u.enabledManagers=[],n.info({config:u},"Repository has PR updates enabled")):!function(e,t){return"scheduled"===e.reason&&t.enabledManagers&&1===t.enabledManagers.length&&""===t.enabledManagers[0]}(e,u)?(u.packageRules||(u.packageRules=[],n.debug({config:u},"Allowing remediating repository to close any open pull requests that may be stale")),u.packageRules.unshift({matchPackagePatterns:["*"],enabled:!1}),n.info({config:u},"Repository is in remediate-only mode")):(n.debug({config:u},"Skipping repository"),u.enabled=!1),u}catch(e){return n.error({err:e},"getRepoConfig error"),{repository:r,enabled:!1}}}}},function(e,t,r){const o=r(1),n=r(5),{logger:s}=r(0),{generateAuthHeaderContent:i}=r(20);function a(e){const t=["maven","gradle","pip","pipenv","nuget"],r={};e.forEach(e=>{const{hostType:o,matchHost:n}=e;t.includes(o)&&(s.debug(`Adding ${n} to default registryUrls for datasource=${o}`),r[o]=r[o]||[],r[o].push(n))});const o=[];for(const[e,t]of Object.entries(r))o.push({matchDatasources:[e],registryUrls:t});return s.debug({hostRules:e,packageRules:o},"Autogenerated registryUrls packageRules from hostRules"),o}e.exports={generatePackageRulesFromHostRules:a,getRemediateConfig:function(){return{branchPrefix:"whitesource-remediate/",enabledManagers:[""],includeForks:!0,onboarding:!1,requireConfig:"optional",suppressNotifications:["missingCredentialsError"],vulnerabilityAlerts:{enabled:!1,ignoreUnstable:!1,groupName:null,schedule:[],dependencyDashboardApproval:!1,labels:["security fix"],commitMessageSuffix:""}}},getRepoDotWhiteSourceConfig:async function(e,t){let r;try{r=await async function(e,t){s.debug("Retrieving repo configuration from controller");const r=e.split("/"),a=r.pop();let u=`owner=${r.join("/")}&repository=${a}`;t&&(u+="&installationId="+t),process.env.WS_CONTROLLER_DESTINATION_URL=process.env.WS_CONTROLLER_DESTINATION_URL||process.env.CONTROLLER_DESTINATION_URL||process.env.BOLT_SERVER_DESTINATION_URL;const c=n(process.env.WS_CONTROLLER_DESTINATION_URL,"/remediate/getRepoSettings?"+u),l={timeout:{request:1e4}};if(process.env.WS_API_SECRET){const e=i(c.split("?")[1],process.env.WS_API_SECRET);l.headers={"ws-auth":e}}let p={};try{p=await o(c,l).json()}catch(e){s.error({err:e,url:c},"Error retrieving repo configuration from the controller")}return p}(e,t),s.debug({config:r},"Repo config from controller")}catch(e){return void s.warn({err:e},"Error fetching .whitesource from controller")}if(!r||"{}"===JSON.stringify(r))return void s.info("Repository is not installed or onboarded");const u={};return r.hostRules&&(u.hostRules=r.hostRules,u.packageRules=a(r.hostRules)),r.scanSettings&&r.scanSettings.baseBranches&&r.scanSettings.baseBranches.length&&(u.baseBranches=r.scanSettings.baseBranches),r.issueSettings&&r.issueSettings.issueType?u.issueSettings={issueType:r.issueSettings.issueType}:u.issueSettings.issueType="VULNERABILITY",r.remediateSettings&&Object.assign(u,r.remediateSettings),r.leastVulnerablePackageSettings&&Object.assign(u,{leastVulnerablePackageSettings:r.leastVulnerablePackageSettings}),u.hostRules&&(u.hostRules=u.hostRules.map(e=>{const t={...e};return e.userName&&(s.debug("Massaging hostRules userName to username"),t.username=e.userName,delete t.userName),t})),u}}},function(e,t,r){const{logger:o}=r(0),{filterRemediateIssues:n}=r(76),{groupRemediations:s}=r(77),i=r(78),{getPackageRulesFromRemediations:a,getEnabledManagers:u}=r(79),c={"bitbucket-server":r(82),github:r(83),gitlab:r(85),azure:r(87),bitbucket:r(88)};e.exports={processRemediateIssues:async function(e,t){const r=process.env.RENOVATE_PLATFORM,l=t.repository,p=await i.fetchIssues(e,t);let d=p.issues;const g=p.mcJwt;let f=[];if(p&&p.shouldQueryIssues&&(d=await c[r].fetchIssues(e,l)),f=n(d),!f.length)return{};o.debug({issues:f},"Found Remediate Issues");const b=s(f,r,e),h=a(b),m=c[r].massagePackageRules(h.packageRules);return{enabledManagers:u(m,h.remediations),packageRules:m,remediations:h.remediations,mcJwt:g}}}},function(e,t,r){const{logger:o}=r(0),n=/<!-- <REMEDIATE>(.*?)<\/REMEDIATE>/;function s(e){return!!e.body&&!!e.body.match(n)}function i(e){const t=e.body.match(n)[1];try{const r=JSON.parse(t);return r&&(Array.isArray(r)?r.forEach(t=>{null!==t.issueNumber&&void 0!==t.issueNumber||(t.issueNumber=e.number||e.iid||e.id)}):null!==r.issueNumber&&void 0!==r.issueNumber||(r.issueNumber=e.number||e.iid||e.id)),{number:e.number||e.iid||e.id,payload:r}}catch(t){o.error({issue:e},"Error parsing issue payload")}return null}function a(e){if(Array.isArray(e.payload)){let t=!1;return e.payload.forEach(e=>{t=t||e.isPackageBased&&e.isOpenPROnVulnerability&&e.packages&&e.packages.length&&e.packages.some(e=>e.minimumFixVersion)}),t?!0:(o.debug({issue:e},"Issue does not need remediation PR"),!1)}return!!(e.payload.isPackageBased&&e.payload.isOpenPROnVulnerability&&e.payload.packages&&e.payload.packages.length&&e.payload.packages.some(e=>e.minimumFixVersion))||(o.debug({issue:e},"Issue does not need remediation PR"),!1)}e.exports={filterRemediateIssues:function(e){if(!e)return[];o.trace({issues:e},"Open issues"),o.debug({count:e.length},"Open issues");let t=e.filter(s);return t.length?(o.debug({count:t.length},"Issues with REMEDIATE JSON"),t=t.map(i).filter(Boolean),t.length?(o.debug({count:t.length},"Issues with parsed REMEDIATE JSON"),t=t.filter(a),o.debug({count:t.length},"Issues needing remediation"),t):[]):[]}}},function(e,t,r){const o=r(6),{logger:n}=r(0),{whitesourceToRenovateDatasourceMapping:s}=r(21);function i(e,t){return"github"===e&&"github.com"===process.env.WS_PLATFORM&&t.reachabilityAnalyzed}function a(e){return!0===e.reachable?"<p align=\"center\"><a href=\"#\">[<img src='https://whitesource-resources.whitesourcesoftware.com/viaRed.png' width=19 height=20>](## 'The vulnerability is likely to be reachable.')</a></p>":!1===e.reachable?"<p align=\"center\"><a href=\"#\">[<img src='https://whitesource-resources.whitesourcesoftware.com/viaGreen.png' width=19 height=20>](## 'The vulnerability is non-reachable.')</a></p>":""}function u(e,t){const r=e-t;return r>0?e+" (+"+r+"<a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/red_arrow_up.png' width=19 height=20 title = 'Change in the number of vulnerabilities compared to the current version.'></a>)":r<0?e+" ("+r+"<a href=\"#\"> <img src='https://whitesource-resources.whitesourcesoftware.com/green_arrow_down.png' width=19 height=20 title = 'Change in the number of vulnerabilities compared to the current version.'></a>)":e+" (--)"}function c(e,t){if(!t)return null;const r=(100*(e/t-1)).toFixed(0);return r>0?r+"% <a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/red_arrow_up.png' width=19 height=20 title = 'The risk change compared to the current version.'></a>":r<0?r+"% <a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/green_arrow_down.png' width=19 height=20 title = 'The risk change compared to the current version.'></a>":"0%"}function l(e,t){let r=0,o=0,n=0,s=0;return e.vulnerabilities.forEach(e=>{e.score>=0&&e.score<4&&(r+=1),e.score>=4&&e.score<7&&(o+=1),e.score>=7&&e.score<9&&(n+=1),e.score>=9&&e.score<=10&&(s+=1)}),t?{lowSeverityCellValue:u(r,t.lowSeverityCellValue),mediumSeverityCellValue:u(o,t.mediumSeverityCellValue),highSeverityCellValue:u(n,t.highSeverityCellValue),criticalSeverityCellValue:u(s,t.criticalSeverityCellValue),riskChangeCellValue:c(e.totalScore,t.totalScore)}:{lowSeverityCellValue:r,mediumSeverityCellValue:o,highSeverityCellValue:n,criticalSeverityCellValue:s,totalScore:e.totalScore}}function p(e,t,r){return"<details "+("latest"!==r&&"current"!==r?"open":"")+" >\n<summary>Version "+t+" "+{latest:"<a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/latest.png' height=17></a>",current:"<a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/current.png' height=17></a>",suggested:"<a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/recommended_fix.png' height=17></a>",latestSuggested:"<a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/latest.png' height='17'>  <img src='https://whitesource-resources.whitesourcesoftware.com/recommended_fix.png' height='17'></a>"}[r]+" </summary> \n\n| Risk Change <a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/info_icon.png' width=19 height=20 title = 'Risk Change is calculated by our algorithm based on the numbers and severities of vulnerabilities'></a>|<a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/critical_vul.png?' width=19 height=20></a> Critical |<a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20></a> High |<a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20></a> Medium | <a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/low_vul.png?' width=19 height=20></a> Low | \n| --- | --- | --- | --- | --- |\n| "+(e.riskChangeCellValue||"N/A")+" | "+e.criticalSeverityCellValue+" | "+e.highSeverityCellValue+" | "+e.mediumSeverityCellValue+" | "+e.lowSeverityCellValue+" |\n</details>\n\n"}e.exports={groupRemediations:function(e,t,r){const u={},c="DEPENDENCY"===r.issueSettings.issueType;let d=e.map(e=>e.payload);e.length>0&&Array.isArray(e[0].payload)&&(d=d.flat());const g="bitbucket-server"!==t&&e.some(e=>-1!==e.number);return d.sort((e,t)=>{const r=e.cvss3Score||e.cvss2Score,o=t.cvss3Score||t.cvss2Score;return r===o?e.vulnerabilityIdentifier.localeCompare(t.vulnerabilityIdentifier):parseFloat(o)-parseFloat(r)}),d.forEach(e=>{r.leastVulnerablePackageSettings&&r.leastVulnerablePackageSettings.enabled&&e.packages.length>0&&e.packages[0].currentVersionVulnerabilities?function(e,t,r,i){if(n.debug("Processing issue number "+r.issueNumber),n.trace({item:r},"issue payload"),r.isOpenPROnVulnerability&&r.isPackageBased&&r.isDefaultBranch)for(const e of r.packages){const{isTransitiveDependency:t}=e;if(!0===t){n.debug("Skipping transitive dependency");continue}if(!0!==e.isMinimumFixVersionAvailable){n.debug("Skipping package with isMinimumFixVersionAvailable !== true");continue}if(!e.packageType){n.warn("Skipping package with no packageType");continue}if(!e.packageName){n.warn("Skipping package with no packageName");continue}if(!e.packageVersion){n.warn("Skipping package with no packageVersion");continue}if(["JavaScript"].includes(e.packageType))continue;const a=s[e.packageType];if(a){e.packageFilePaths&&e.packageFilePaths.length&&e.packageFilePaths.every(e=>o.nonEmptyString(e))||(e.packageFilePaths=["*"]);for(const o of e.packageFilePaths.filter(Boolean)){const s=o.replace(/^\//,"");i[s]||(i[s]={}),i[s][a]||(i[s][a]={});let{packageName:u,packageVersion:c}=e;e.groupId&&(u=e.groupId+":"+u),c.includes(",")&&(n.warn("Multiple packageVersion values found - using the first"),c=c.split(",")[0]);const d=`${u}@${c}`;if(n.trace(`Grouping based on ${a}/${d}`),!i[s][a][d]){const o=l(e.currentVersionVulnerabilities,null),n=l(e.suggestedVersionVulnerabilities,o),g=l(e.latestVersionVulnerabilities,o);let f="#### This PR resolves the vulnerabilities described in Issue #"+r.issueNumber+"\n---\n\n";const b=e.suggestedVersionVulnerabilities.version===e.latestVersionVulnerabilities.version?"latestSuggested":"suggested";f+=p(o,e.currentVersionVulnerabilities.version,"current"),f+=p(n,e.suggestedVersionVulnerabilities.version,b),e.suggestedVersionVulnerabilities.version!==e.latestVersionVulnerabilities.version&&(f+=p(g,e.latestVersionVulnerabilities.version,"latest")),f+='#### Mend ensures you have the greatest risk reduction ("Recommended Fix"-highlighted in green) by removing as many vulnerabilities as possible. Click to see [how we calculate risk reduction](https://docs.mend.io/bundle/integrations/page/least_vulnerable_packages_feature.html).',i[s][a][d]={packageName:u,packageVersion:c,issues:[],minimumFixVersions:[],prBodyNote:f,isTransitiveDependency:t,isLeastVulnerablePackageEnabled:!0,kpiData:{libraryData:{libraryName:e.packageName,libraryVersion:e.packageVersion,libraryFixVersion:e.minimumFixVersion,libraryArtifactId:e.packageName,libraryGroupId:e.groupId,language:e.packageType},vulnerabilityData:[]}}}if(r.issueNumber&&!i[s][a][d].issues.includes(r.issueNumber)&&i[s][a][d].issues.push(r.issueNumber),!e.minimumFixVersion){n.warn({pkg:e},"No minimumFixVersion");continue}const g=e.minimumFixVersion.split(";");let f;i[s][a][d].minimumFixVersions=g;const b=r.cvss3Score||r.cvss2Score;r.cvss3Severity?f=r.cvss3Severity[0].toUpperCase()+r.cvss3Severity.slice(1):r.cvss2Severity?f=r.cvss2Severity[0].toUpperCase()+r.cvss2Severity.slice(1):n.warn("No CVSS2 or CVSS3 severity found in issue"),i[s][a][d].kpiData.vulnerabilityData.push({severity:f,score:b,vulnerabilityId:r.vulnerabilityIdentifier}),i[s][a][d].prBodyNote+="\n"}}else n.warn({pkg:e},"packageType is not known to Remediate - skipping")}else n.trace({isOpenPROnVulnerability:r.isOpenPROnVulnerability,isPackageBased:r.isPackageBased,isDefaultBranch:r.isDefaultBranch},"Skipping issue because of a false field in the meta data.")}(0,r.transitiveRemediation,e,u):function(e,t,r,u,c,l){if(n.debug("Processing issue number "+r.issueNumber),n.trace({item:r},"issue payload"),r.isOpenPROnVulnerability&&r.isPackageBased&&r.isDefaultBranch)for(const p of r.packages){const{isTransitiveDependency:d}=p;if(!0===d&&("javascript/Node.js"!==p.packageType||!t)){n.debug("Skipping transitive dependency");continue}if(!0!==p.isMinimumFixVersionAvailable){n.debug("Skipping package with isMinimumFixVersionAvailable !== true");continue}if(!p.packageType){n.warn("Skipping package with no packageType");continue}if(!p.packageName){n.warn("Skipping package with no packageName");continue}if(!p.packageVersion){n.warn("Skipping package with no packageVersion");continue}if(["JavaScript"].includes(p.packageType))continue;const g=s[p.packageType];if(g){p.packageFilePaths&&p.packageFilePaths.length&&p.packageFilePaths.every(e=>o.nonEmptyString(e))||(p.packageFilePaths=["*"]);for(const t of p.packageFilePaths.filter(Boolean)){const o=t.replace(/^\//,"");u[o]||(u[o]={}),u[o][g]||(u[o][g]={});let{packageName:s,packageVersion:f}=p;p.groupId&&(s=p.groupId+":"+s),f.includes(",")&&(n.warn("Multiple packageVersion values found - using the first"),f=f.split(",")[0]);const b=`${s}@${f}`;n.trace(`Grouping based on ${g}/${b}`);const h=c&&!l,m=i(e,r);if(!u[o][g][b]){let t="By merging this PR, the below vulnerabilities will be automatically resolved:\n\n";h&&(t="By merging this PR, the below issues will be automatically resolved and closed:\n\n"),c&&l&&r.issueNumber&&-1!==r.issueNumber&&(t=`By merging this PR, the issue #${r.issueNumber} will be automatically resolved and closed:\n\n`),t+="| Severity           ","bitbucket"===process.env.WS_PLATFORM?t+="| 🎯 CVSS Score       ":t+="| <a href='#'><img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width='19' height='20'></a> CVSS Score       ",t+="|CVE  |",m&&(t+=" Reachability |"),h&&("bitbucket"===process.env.WS_PLATFORM?t+=" Issue |":t+=" GitHub Issue |"),t+=h?"\n|---|---|---|---|":"\n|---|---|---|",m&&(t+="---|"),t+="\n","gitlab"===e&&(t=t.replace(/GitHub/g,"GitLab").replace(/PR/g,"MR")),"azure"===e&&(t=t.replace(/GitHub/g,"Azure").replace(/Issue/g,"Work Item")),u[o][g][b]={packageName:s,packageVersion:f,issues:[],minimumFixVersions:[],prBodyNote:t,isTransitiveDependency:d,kpiData:{libraryData:{libraryName:p.packageName,libraryVersion:p.packageVersion,libraryFixVersion:p.minimumFixVersion,libraryArtifactId:p.packageName,libraryGroupId:p.groupId,language:p.packageType},vulnerabilityData:[]}}}if(r.issueNumber&&!u[o][g][b].issues.includes(r.issueNumber)&&u[o][g][b].issues.push(r.issueNumber),!p.minimumFixVersion){n.warn({pkg:p},"No minimumFixVersion");continue}let v;p.minimumFixVersion.split(";").forEach(e=>{u[o][g][b].minimumFixVersions.includes(e)||u[o][g][b].minimumFixVersions.push(e)});const y=r.cvss3Score||r.cvss2Score;r.cvss3Severity?v=r.cvss3Severity[0].toUpperCase()+r.cvss3Severity.slice(1):r.cvss2Severity?v=r.cvss2Severity[0].toUpperCase()+r.cvss2Severity.slice(1):n.warn("No CVSS2 or CVSS3 severity found in issue");let E="";if("bitbucket-server"===e&&(E="{width=20 height=20}"),u[o][g][b].prBodyNote+="bitbucket"===e?"|":h?`| <a href='#'><img src='https://whitesource-resources.whitesourcesoftware.com/${v.toLowerCase()}_vul.png?' width='19' height='20'></a>`:`| ![${v}](https://whitesource-resources.whitesourcesoftware.com/${v.toLowerCase()}_vul_bb.png?)${E}`,u[o][g][b].prBodyNote+=` ${v} | ${y} | [${r.vulnerabilityIdentifier}](${r.vulnerabilityUrl}) |`,m){const e=a(r);u[o][g][b].prBodyNote+=` ${e} |`}u[o][g][b].kpiData.vulnerabilityData.push({severity:v,score:y,vulnerabilityId:r.vulnerabilityIdentifier}),h&&(u[o][g][b].prBodyNote+=` #${r.issueNumber} |`),u[o][g][b].prBodyNote+="\n"}}else n.warn({pkg:p},"packageType is not known to Remediate - skipping")}else n.trace({isOpenPROnVulnerability:r.isOpenPROnVulnerability,isPackageBased:r.isPackageBased,isDefaultBranch:r.isDefaultBranch},"Skipping issue because of a false field in the meta data.")}(t,r.transitiveRemediation,e,u,g,c)}),u}}},function(e,t,r){const o=r(5),{logger:n}=r(0),s=r(1),{generateAuthHeaderContent:i}=r(20);e.exports={fetchIssues:async function(e,t){if("bitbucket-server"===process.env.WS_PLATFORM)return{shouldQueryIssues:!0};const r=t.repository;let a;if("azure"===process.env.RENOVATE_PLATFORM)a={},a.id=t.params.repoId,a.accountId=t.params.accountId,a.installationId=t.params.collectionId,a.repositoryName=r;else if("bitbucket"===process.env.RENOVATE_PLATFORM)a={},a.id=t.params.repoId,a.accountId=t.params.accountId,a.installationId=t.installationId,a.repositoryName=r;else{global.repoVerboseList=global.repoVerboseList||[];let e=global.repoVerboseList.find(e=>e.repository===r);if(!e&&(e=await async function(e,t){try{if("gitlab"===process.env.RENOVATE_PLATFORM){const r=e.replaceAll("/","%2F"),i=o(process.env.RENOVATE_ENDPOINT,"projects/"+r);n.info(i);const a={headers:{"PRIVATE-TOKEN":process.env.RENOVATE_TOKEN},timeout:{request:1e4}},u=await s(i,a).json();if(u&&u.namespace){const e={repository:u.path_with_namespace,id:u.id,accountId:u.namespace.id,accountType:u.namespace.kind,installationId:t};return global.repoVerboseList.push(e),e}}else if("github"===process.env.RENOVATE_PLATFORM){const r=o(process.env.RENOVATE_ENDPOINT,"repos/"+e);n.info(r);const i={headers:{accept:"application/vnd.github.machine-man-preview+json",authorization:"Bearer "+process.env.RENOVATE_TOKEN,timeout:{request:1e4}}},a=await s(r,i).json();if(a&&a.owner){const e={repository:a.full_name,id:a.id,accountId:a.owner.id,installationId:t};return global.repoVerboseList.push(e),e}}}catch(e){e.statusCode&&e.statusCode>=500&&e.statusCode<600?n.warn({err:e},"Error reaching SCM API. Unable to get project verbose data."):n.warn({err:e,message:e.message},"Unknown API error")}return null}(r,t.installationId),!e))return n.debug({matchedRepo:e},"Unable to get repository data to get issuses from"),{shouldQueryIssues:!0};a=e}let u=`repoId=${a.id}&accountId=${a.accountId}&installationId=${a.installationId}&repoName=${r}`;a.accountType&&(u+="&accountType="+a.accountType);const c=o(process.env.WS_CONTROLLER_DESTINATION_URL||process.env.CONTROLLER_DESTINATION_URL,"remediate?"+u);n.debug({url:c},"Retrieving issues list from Controller API");const l={timeout:{request:3e4}};if(process.env.WS_API_SECRET){const e=i(c.split("?")[1],process.env.WS_API_SECRET);l.headers={"ws-auth":e}}const p=await s(c,l).json();if(!p)return n.debug({url:c},"No issues provided by the controller. Fallback to getting issues from scm provider"),{shouldQueryIssues:!0};let d;if(p.mcJwt&&(d=p.mcJwt),p.shouldQueryIssues)return n.debug("Issues should be retrieved directly from the scm provider"),{issues:p,mcJwt:d};if(!p.remediation)return n.info("No issues from controller"),{mcJwt:d};const g=[];return p.remediation.forEach(e=>{e.isPackageBased=e.isPackageBased||e.packageBased,e.isDefaultBranch=e.isDefaultBranch||e.defaultBranch,e.isOpenPROnVulnerability=e.isOpenPROnVulnerability||e.openPROnVulnerability,e.packages.forEach(e=>{e.isTransitiveDependency=e.isTransitiveDependency||e.transitiveDependency,e.isMinimumFixVersionAvailable=e.isMinimumFixVersionAvailable||e.minimumFixVersionAvailable});const t=null!==e.issueNumber&&void 0!==e.issueNumber?e.issueNumber:-1,r={body:"\x3c!-- <REMEDIATE>"+JSON.stringify(e)+"</REMEDIATE>",id:t};g.push(r)}),{issues:g,mcJwt:d}}}},function(e,t,r){const{logger:o}=r(0),n=r(80),s=r(81),{datasourceManagers:i}=r(21),a={go:n.get("semver"),maven:n.get("maven"),npm:n.get("npm"),packagist:n.get("composer"),nuget:n.get("nuget"),pypi:n.get("pep440"),rubygems:n.get("ruby")};function u(e,t){const r=new RegExp(t+"\\s*(-|:)\\s*");return e.replace(r,"")}function c(e,t){let r=u(e,t);const n=t.replace(/^.*?\/(.*?)(\..*)?$/,"$1");return n&&(r=u(r,n)),r!==e&&o.debug({original:e,res:r},"Massaged fixed-in version string"),r}function l(e,t){return t.libraryData.libraryFixVersion=e,"\x3c!--[REMEDIATE_ANALITICS]"+JSON.stringify(t)+"[/REMEDIATE_ANALITICS]--\x3e"}e.exports={getPackageRulesFromRemediations:function(e){const t=[],r={};for(const[n,i]of Object.entries(e))for(const[e,u]of Object.entries(i)){o.debug({datasource:e,packages:u},"Processing datasource");for(const i of Object.values(u)){const{isTransitiveDependency:u,minimumFixVersions:p,packageName:d,packageVersion:g,prBodyNote:f,kpiData:b}=i,h=a[e];if(!h.isVersion(g)){o.warn({details:i},"packageVersion is not a valid version so cannot compare/upgrade");continue}let m;for(const t of p){o.trace({minFixStr:t});const r=t.split(",").map(e=>e.trim()),n=r.map(e=>c(e,d));let a=n;"npm"===e&&(a=a.map(e=>s.coerce(e).version));const u=a.filter(e=>h.isVersion(e)),l=[...new Set(u)].filter(e=>h.isGreaterThan(e,g)).sort((e,t)=>h.sortVersions(e,t));if(!l.length){["node-sass"].includes(i.packageName)||o.info({details:i,transform:{allFixVersions:r,massagedFixVersions:n,coercedFixVersions:a,validFixVersions:u,greaterThanFixVersions:l}},"No minimumFixVersion remaining - remediation cannot be performed");continue}const p=l[0];m?h.isGreaterThan(p,m)?(o.debug({minimumFixVersion:m,thisMinFix:p},"thisMinFix is higher"),m=p):o.debug({minimumFixVersion:m,thisMinFix:p},"thisMinFix is lower"):m=p}if(!m){o.info("No minimumFixVersion");continue}o.debug("consolidated minimumFixVersion="+m);let v,y=g;"pypi"===e&&(y="=="+y),v="maven"===e?`[${m},)`:">= "+m,h.isValid(v)||a.npm.isValid(v)||(h.isValid(m)||a.npm.isValid(m)?(o.info({datasource:e,minimumFixVersion:m},"Falling back to single allowedVersions"),v=m):(o.warn({datasource:e,minimumFixVersion:m},"Cannot determine valid allowedVersions"),v=null));const E=[d];if(d!==d.toLowerCase()&&E.push(d.toLowerCase()),v){let o;o="github.com"===process.env.WS_PLATFORM?[f+l(m,b)]:[f];const s={matchDatasources:[e],matchPackageNames:E,matchCurrentVersion:y,allowedVersions:v,vulnerabilityAlert:!0,enabled:!0,ignoreUnstable:!1,groupName:null,schedule:[],dependencyDashboardApproval:!1,labels:["security fix"],prBodyTemplate:"{{{table}}}{{{notes}}}{{{changelogs}}}{{{controls}}}",prBodyNotes:o,isVulnerabilityAlert:!0,commitMessageSuffix:"",suppressNotifications:["prIgnoreNotification","prEditNotification"]};if("*"!==n&&n.endsWith("package.json")&&(s.matchFiles=[n]),"npm"===e&&(s.rangeStrategy="update-lockfile"),u){const t=n.replace(/package.json$/,"package-lock.json");r[t]=r[t]||[];const s={datasource:e,depName:d,currentVersion:g,newVersion:m,prBodyNotes:o,commitMessageSuffix:""};r[t].push(s)}else t.push(s)}}}return o.debug({packageRules:t}),{packageRules:t,remediations:r}},getEnabledManagers:function(e,t){const r=[""];if(e.length)for(const t of e)if(t.matchDatasources&&t.matchDatasources.length){const e=t.matchDatasources[0];for(const t of i[e])r.includes(t)||r.push(t)}return Object.keys(t)&&(r.includes("npm")||r.push("npm")),r}}},function(e,t){e.exports=require("renovate/dist/modules/versioning")},function(e,t){e.exports=require("semver")},function(e,t,r){const o=r(5),{logger:n}=r(0),s=r(1);e.exports={fetchIssues:async function(e,t){n.debug("Retrieving issues list from Bitbucket API");const r=o(process.env.RENOVATE_ENDPOINT,`/plugins/servlet/whitesource/repository/${t}/build/report`);try{const e={requestType:"getIssues"};return await s.post(r,{json:e,headers:{Authorization:"Bearer "+process.env.RENOVATE_PASSWORD}}).json()}catch(e){return n.error({err:e,url:r},"Could not retrieve Bitbucket issues"),[]}},massagePackageRules:function(e){for(const t of e)t.prBodyNotes&&(t.prBodyNotes[0]=t.prBodyNotes[0].replace(/<a.*?<\/a>/g,""));return e}}},function(e,t,r){const o=r(5),{logger:n}=r(0),{GithubHttp:s}=r(84),i=new s;e.exports={fetchIssues:async function(e,t){n.debug("Retrieving issues list from GitHub API");const r=o(process.env.RENOVATE_ENDPOINT,`repos/${t}/issues?state=open&per_page=100`),s={paginate:!0,useCache:!1};let a=[];try{a=(await i.getJson(r,s)).body}catch(e){n.debug("Repository has issues disabled"),n.trace({err:e,url:r},"Cannot fetch repository issues")}return a},massagePackageRules:function(e){return e}}},function(e,t){e.exports=require("renovate/dist/util/http/github")},function(e,t,r){const o=r(5),{logger:n}=r(0),{GitlabHttp:s}=r(86),i=new s;e.exports={fetchIssues:async function(e,t){const r=o(process.env.RENOVATE_ENDPOINT,`projects/${t.replace(/\//g,"%2f")}/issues?state=opened`);n.debug({url:r},"Retrieving issues list from GitLab API");const s={paginate:!0,useCache:!1};let a=[];try{a=(await i.getJson(r,s)).body,a=a.map(e=>{const t={...e};return t.body=t.description,delete t.description,t})}catch(e){n.info({err:e,url:r},"Error retrieving issues list")}return a},massagePackageRules:function(e){return e}}},function(e,t){e.exports=require("renovate/dist/util/http/gitlab")},function(e,t){e.exports={massagePackageRules:function(e){return e}}},function(e,t){e.exports={massagePackageRules:function(e){return e}}}]);